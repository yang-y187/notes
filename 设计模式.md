# 1，设计模式简介

## 设计模式概念

软件设计模式，**代码设计经验的总结**。描述了在软件设计过程中不断发生的问题，以及该问题的解决方案。更多的是对代码设计经验的总结模式，方便套用。 

## 设计模式分类

- 创建型模式
  - 用于描述怎样创建对象，主要特点就是将**对象的创建和使用分离**，包括单例，原型，工厂方法，抽象工厂，建造者，5种模式
- 结构型模式
  -   用于描述如何将类或者对象按某种布局组成更大的结构，代理，适配器，桥接，装饰，外观，享元，组合，7种模式
- 行为型模式
  - 描述类或者对象之间如何相互协作，共同完成单个对象无法单独完成的任务和分配职责。模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器，11种行为型模式。



# 2, UML图

 UML是用于设计软件的可视化统一建模语言。它的特点是简单，统一，图形化，能表达软件设计中的动态和**静态信息**

从设计目标的不同，可以分为：用例图，**类图**，对象图，状态图，活动图，时序图，协作图，构件图，部署图等9种



## 类图的概述

类图显示了模型的静态结构，特别是模型中存在的类，类的内部结构以及它们与其台类的关系等，类图不显示暂时性的信息，类图是面向对象建模的主要组成部分。

## 类图表示

![img](设计模式.assets/v2-5c69cd9ff703377f7bbf37cee8199451_720w.webp)

类图中，类使用包含类名，属性和方法

属性/方法名称前加的加号和减号表示这个属性/方法的可见性，UML类图中表示可见性的符合有三种：

- +：表示public
- -: 表示private
- \#:表示protected

属性的完整表示方式： **可见性 名称 ：类型[ =缺省值]** 

方法的完整表示方式：**可见性 名称（参数列表）[:返回值类型]**

[] 中括号为可有可无的初始化值。 



## 类之间关系的表示方式

- 关联关系
  -   单向关联
  - 双向关联
  - 自关联
- 聚合关系
- 组合关系

### 关联关系

#### 单向关联

在UML类中，用一个带箭头的实线表示，图中表示每个顾客类都持有一个地址类型的成员变量实现

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-3275137.png)

#### 双向关联

双向关联用一个不带箭头的实线表示，两个类中均持有对方类型的成员变量

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230505162807228.png)

#### 自关联

自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是"自己包含自己"。【LinkedList底层用到了自关联】

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230505163303881.png)

### 聚合关系

聚合关系是强关联关系，整体和部分的关系。成员对象是整体对象的一部分，但成员对象可以脱离整体对象而存在。

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230505164318184.png)

### 组合关系

==组合关系表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。==

组合关系中，整体对象可以控制部分的生命周期，一旦整体对象不存在，部分对象不能脱离整体而存在。

在UML类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230508091838682.png)

### 依赖关系

依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，使是临时性的关联。

在代码中，某个类的方法通过局部变量，方法的参数或者静态方法的调用来访问另一个类中的某些方法来完成职责。

**![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230508092618983.png)**

### 继承关系

继承关系是对象之间耦合对最大的一种关系。

在UML类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230508092752689.png)

### 实现关系

实现关系是接口与实现类之间的关系，类实现了接口，类中的操作实现了接口中所声明的所有抽象方法。



# 3，软件设计原则

软件设计中，为了提高软件系统的可维护性和可复用性，增加软件的可拓展性和灵活性，程序员要尽量根据6条原则开发程序，从而提高软件开发效率，节约软件开发成本和维护成本。



## 3.1 开闭原则

**对拓展开放，对修改关闭**。

==程序需要拓展时，不能去修改原有代码，而是实现热插拔的效果。==为了使程序的拓展性好，易于维护和升级。我们使用**接口和抽象类**,因为抽象类灵活性好，适用性广。我们可以通过抽象派生出的实现类来进行拓展。，若需求发生变化，则根据需要派生出一个新的实现类来拓展即可。



## 3.2 里氏代换原则

里氏代换原则是面向对象设计的基本原则之一

里氏代换原则：任何基类可以出现的地方，子类也可出现。可理解为：**子类继承父类时，进行是新增方法，而不是重写父类已有的方法**

子类虽然可以重写父类的方法来完成指定的功能，但整个继承体系的可复用性则会变差，尤其在使用多态频繁的场景。

理解为：重写父方法虽然可完成个别指定的功能，在多态的多场景下，未必完全适用。

## 3.3 依赖倒转原则

高层模块不能依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

**可理解为：对传入参数或者属性选择抽象类或者接口，而不必是具体类，避免无法变更该类，即set属性为学生，但我们类的属性类型应选择人（抽象类），因为可能参数变更为老师**， 类依赖抽象，而不是依赖于具体实现类

## 3.4 接口隔离原则

客户端不应该依赖它不使用的方法，一个类对另一个的依赖应该建立在最小的接口上。

**可理解为：子类A依赖B的方法1，但不依赖B的方法2，所以将方法1，方法2写入两个接口上，A只实现接口1，类B实现接口1,2**，则是一个类对另一个类的依赖应取最小的依赖权限

## 3.5 迪米特原则

迪米特原则：最少知识原则

两个软件实体无须直接通信，那么不应该直接相互调用，可以通过第三方转发该调用。

目的：降低类之间的耦合度，提高模块的相对独立性。

两个软件的关系：当前对象本身，当前对象的成员对象，当前对象所创建的对象，当前对象的方法参数等，这些对象同当前对象存在关联，聚合等关系，可访问这些对象的方法。

**可理解为：万事万物皆对象，需要将某些属性，方法抽成类对象，调用该类对象的属性，方法，而不是直接编写属性，方法**

## 3.6 合成复用原则

尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

通常类的复用分为继承复用和合成复用两种

- **继承复用**：虽然简单和容易实现，但也有一些缺点
  - 继承复用破坏了类的封装性，因为继承会将父类的实现细节暴露给子类，即子类拥有父类的属性和方法
  - 子类和父类耦合度高，父类的实现的任何改变，都会对子类产生影响，不利于类的拓展和维护
  - 它限制了复用的灵活性，从父类继承而来的实现是静态的，编译时已经生成，无法修改
- **组合复用**：将已有对象纳入新对象时，使之成为新对象的一部分，新对象可以抵用已有对象的功能
  - 它维持了类的封装性
  - 对象的耦合度低
  - 复用的灵活性高。（可以属性为父类，抽象类等，传入子类，增加灵活性）



汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： 

![image-20230520120456688](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230520120456688-16845554997623-16845555016495.png)

从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。

![image-20230520120515345](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230520120515345-16845555169317.png)

# 4 创建者模式

创建者模式：主要关注怎样创建对象，将对象的创建和使用分离

创建者模式分为：

- 单例模式
- 工厂方法模式
- 抽象工程模式
- 原型模式
- 建造者模式

## 4.1 单例模式

单例模式分为**饿汉式**和**懒汉式**

- 饿汉式：类加载就会创建该实例类
- 懒汉式：类加载时不会创建单例对象，在首次获取该处对象时，才会被创建

### 单例模式实现方式

#### 饿汉式-方式1（静态变量方式）

```java
/**
 * 饿汉式
 *      静态变量创建类的对象
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance = new Singleton();

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

说明：

该方式通过静态变量，在类加载时创建对象，若对象太大，而一直未使用，则造成内存浪费

#### 饿汉式-方式2（静态代码块方式）

```java
/**
 * 恶汉式
 *      在静态代码块中创建该类对象
 */
public class Singleton {

    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    static {
        instance = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

说明：

与方式1相仿

#### 懒汉式-方式1（线程不安全）

```java
/**
 * 懒汉式
 *  线程不安全
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {

        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

<font color='red'>说明：</font>

线程不安全，在多个线程同时第一次调用该对象时，发现该对象为null，多线程都创建了new singleton，并返回。则创建出了多个singleton

#### 懒汉式-方式2（线程安全）

```java
/**
 * 懒汉式
 *  线程安全
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static synchronized Singleton getInstance() {

        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

<font color='red'>说明：</font>

在获取对象方法上，加synchronized关键字，导致该方法的执行效率低，因为只有在创建对象时，存在线程安全问题，创建完成后，只是读取单例的地址不存在线程安全。所以有性能低的问题

#### 懒汉式-方式3（双重检查锁）

在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。注意需要添加volatile 关键字，来保证可见性和有序性

```java
public final class Singleton {
    private Singleton() { }
        // 问题1：解释为什么要加 volatile ?
        private static volatile Singleton INSTANCE = null;
        // 问题2：对比上个实现, 说出这样做的意义
        public static Singleton getInstance() {
            if (INSTANCE != null) {
            	return INSTANCE;
            }
            synchronized (Singleton.class) {
                // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗
                if (INSTANCE != null) { // t2
                	return INSTANCE;
                }
            INSTANCE = new Singleton();
            return INSTANCE;
        }
    }
}
```

- 问题1：
  - **volatile此时主要是避免因为指令重排而出现的问题**
    - 若创建对象 [INSTANCE = new Singleton()] 出现重排序，先给INSTANCE赋予地址值，但单实例此时没有完全初始化。后续线程进入getInstance方法，因为INSTANCE不为空（第一个判断），会获取到还没有初始化完成的单实例。**单实例有问题**
  - volatile加入了写屏障，使得INSTANCE赋值之前，其他指令已经完成。
  - 保证了可见性
- **问题2：实现3为在单实例获取方法上加synchronized**
  - 避免了已经创建对象，却仍要竞争锁的情况，（影响速度）
- **问题3：**
  - 在INSTANCE为null时，多个线程同时来获取单实例，第一次判断INSTANCE为null。只有一个线程竞争到锁并创建了对象，其他线程也会继续竞争锁，进入synchronized方法，若没有该判断，则会继续创建对象，而不是使用已经创建的对象

#### 懒汉式-方式4（静态内部类方式）

静态内部类单例模式中实例由内部类创建，由于jvm在加载外部类时，不会加载静态内部类，只有内部类的属性/方法被调用时才会被加载，并初始化内部类的静态属性。而且静态属性因为static修饰，属于类，只初始化一次，保证了实例化顺序

```java
/**
 * 静态内部类方式
 */
public class Singleton {

    //私有构造方法
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

<font color='red'>说明：</font>

 第一次加载Singleton类时，不会初始化单例对象，只有在第一次调用getInstance方法时，虚拟机才加载内部类，并初始化，既保证了线程安全，又保证了唯一性。（因为类加载只加载一次）

<font color="red">小结：</font>

**静态内部类单例模式是一种优秀的单例模式，而且非常常见，没有加锁，既保证了线程安全，又没有性能和空间的浪费。**

#### 枚举方式

**枚举类单例模式是线程安全的，并且只会被加载一次，枚举的写法简单，并且唯一不会被破坏的单例实现模式**

```java
/**
 * 枚举方式
 */
public enum Singleton {
    INSTANCE;
}
```

<font color='red'>说明：</font>

 枚举属于饿汉式

### 单例设计模式问题

单例被破坏的方法：**序列化反序列化和反射**，但枚举方式的单例不会被这两个破坏。

- #### 反序列化破坏单例模式解决方案

在单例类Singleton中，添加`readResolve()`方法，在反序列时被反射调用，如果定义了这个方法，就返回该方法的返回值，如果没有定义，则通过反射new一个新的对象

```java
public class Singleton implements Serializable {

    //私有构造方法
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
    
    /**
     * 下面是为了解决序列化反序列化破解单例模式
     */
    private Object readResolve() {
        return SingletonHolder.INSTANCE;
    }
}
```



源码解析：

ObjectInputStream类

```java
public final Object readObject() throws IOException, ClassNotFoundException{
    ...
    // if nested read, passHandle contains handle of enclosing object
    int outerHandle = passHandle;
    try {
        Object obj = readObject0(false);//重点查看readObject0方法
    .....
}
    
private Object readObject0(boolean unshared) throws IOException {
	...
    try {
		switch (tc) {
			...
			case TC_OBJECT:
				return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法
			...
        }
    } finally {
        depth--;
        bin.setBlockDataMode(oldMode);
    }    
}
    
private Object readOrdinaryObject(boolean unshared) throws IOException {
	...
	//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，
    obj = desc.isInstantiable() ? desc.newInstance() : null; 
    ...
    // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true
    if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) {
    	// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量
    	// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。
    	Object rep = desc.invokeReadResolve(obj);
     	...
    }
    return obj;
}
```

- #### 反射破坏单例模式解决方案

  ```java
  public class Singleton {
  
      //私有构造方法
      private Singleton() {
          /*
             反射破解单例模式需要添加的代码
          */
          if(instance != null) {
              throw new RuntimeException();
          }
      }
      
      private static volatile Singleton instance;
  
      //对外提供静态方法获取该对象
      public static Singleton getInstance() {
  
          if(instance != null) {
              return instance;
          }
  
          synchronized (Singleton.class) {
              if(instance != null) {
                  return instance;
              }
              instance = new Singleton();
              return instance;
          }
      }
  }
  ```

  <font color="red">说明:</font>

  破坏单例的创建，不允许通过反射创建多个对象。

### JDK源码中的单例模式

Runtime类使用饿汉式（静态属性）单例设计模式

```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    /**
     * Returns the runtime object associated with the current Java application.
     * Most of the methods of class <code>Runtime</code> are instance
     * methods and must be invoked with respect to the current runtime object.
     *
     * @return  the <code>Runtime</code> object associated with the current
     *          Java application.
     */
    public static Runtime getRuntime() {
        return currentRuntime;
    }

    /** Don't let anyone else instantiate this class */
    private Runtime() {}
    ...
}
```

## 4.2 工厂模式

java中，万物皆对象，对象创建需要new对象，耦合眼红，如果更改对象，需要将所有new对象的位置都改。未被了软件设计的开闭原则。因此，我们选择工厂来生产对象，使用对象，只从工厂获取，如果更换对象，在工厂内更换，达到对象解耦的目的。工厂模式的最大优点：**解耦**

工厂模式：

- 简单工厂模式 (不是设计模式，更像是一种编程习惯)
- 工厂方法模式
- 抽象工厂模式

### 简单工厂模式

简单工厂不是设计模式，更多的像是一种编程习惯。开发过程中，很多奖工厂类里的创建对象功能设为静态的static，即静态工厂模式，此模式也是开发习惯，而非设计模式

简单工厂提供的角色：

- 抽象产品：定义了对象的基本规范，描述了主要特性
- 具体产品：实现或者继承类的子类
- 具体工厂：提供了创建对象的方法，调用者通过该方法获取想要的对象



对象的创建和使用分开。创建对象，根据传参在SimpleFactory中创建各种对象，使用对象时，从SimpleFactory中获取。解除了调用方与对象实现类的耦合。但产生了新的耦合。对象和生产对象的工厂的耦合，工厂对象和产品对象的耦合。

如果后期添加新的产品对象，仍需要更改工厂对象的代码，违反了开闭原则。

#### 实现

```java
public class SimpleCoffeeFactory {

    public Coffee createCoffee(String type) {
        Coffee coffee = null;
        if("americano".equals(type)) {
            coffee = new AmericanoCoffee();
        } else if("latte".equals(type)) {
            coffee = new LatteCoffee();
        }
        return coffee;
    }
}
```

#### 优缺点

##### **优点：**

封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑分开。在以后有新对象创建时，不必更改原有代码，只更改工厂类即可。容易拓展

##### 缺点：

新增产品对象后，仍需要更改工厂类对象，违背了开闭原则



### 模式拓展

简单工厂+配置文件解除耦合

通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合，具体实现是在工厂类中加载配置文件中全类名，创建对象并存储到map中，客户端如果需要对象，则可以直接获取。

#### 一 定义配置文件

```properties
american=com.itheima.pattern.factory.config_factory.AmericanCoffee
latte=com.itheima.pattern.factory.config_factory.LatteCoffee
```

#### 二 工厂类 

```java
public class CoffeeFactory {

    private static Map<String,Coffee> map = new HashMap();

    static {
        Properties p = new Properties();
        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream("bean.properties");
        try {
            p.load(is);
            //遍历Properties集合对象
            Set<Object> keys = p.keySet();
            for (Object key : keys) {
                //根据键获取值（全类名）
                String className = p.getProperty((String) key);
                //获取字节码对象
                Class clazz = Class.forName(className);
                Coffee obj = (Coffee) clazz.newInstance();
                map.put((String)key,obj);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static Coffee createCoffee(String name) {

        return map.get(name);
    }
}
```

静态代码段，表示只需要执行一次，并存储在静态变量map中



### 工厂方法模式

简单工厂模式在新增产品对象后，仍需要更改工厂类对象，违背开闭原则。该工厂方法模式可以完美解决。

#### 概念

定义了一个创建对象的接口，该子类决定实例化哪个产品对象，该工厂方法使产品的实例化延迟到该工厂的子类中。

#### 结构：

- 抽象工厂：提供工厂的抽象类或者接口标准，可调用该类的具体实现创建产品
- 具体工厂：实现抽象工厂的抽象方法，完成具体产品的创建
- 抽象产品：定义了产品的规范，包括特性和功能
- 具体产品：实现了抽象产品所定义的接口，由具体工厂进行创建

#### 实现

![image-20230529100138030](设计模式.assets/image-20230529100138030.png)

代码如下：

抽象工厂：

```java
public interface CoffeeFactory {

    Coffee createCoffee();
}
```

具体工厂：

```java
public class LatteCoffeeFactory implements CoffeeFactory {

    public Coffee createCoffee() {
        return new LatteCoffee();
    }
}

public class AmericanCoffeeFactory implements CoffeeFactory {

    public Coffee createCoffee() {
        return new AmericanCoffee();
    }
}
```

**咖啡店类：**

```java
public class CoffeeStore {

    private CoffeeFactory factory;

    public CoffeeStore(CoffeeFactory factory) {
        this.factory = factory;
    }

    public Coffee orderCoffee(String type) {
        Coffee coffee = factory.createCoffee();
        coffee.addMilk();
        coffee.addsugar();
        return coffee;
    }
}
```

在该模式下，若增加新的产品类，不需要更改工厂类对象，只需要创建新的工厂类，并作为参数传入该对象。

#### 优缺点

**优点**

- 用户只需要知道具体工厂的名称就可以获取产品，调用方与产品对象的创建隔离
- 新增产品时，只需要增加具体的产品类和工厂类，无需更改原有代码，满足开闭原则（不更改已有的业务代码）

缺点：

- 每增加一个产品，都需要增加一个具体的产品类和工厂类，增加了系统复杂度



### 抽象工厂模式

工厂方法模式中，工厂只考虑一类产品生产，但很多时候，一个具体工厂可能生产多种同级产品，比如苹果工厂生产手机，电脑，耳机等。此时，需要抽象工厂模式进行实现

#### 概念

为访问类提供一个创建一组或相互依赖对象的接口，且访问类没有指定所要产品的具体类，就能得到该产品

抽象工厂模式是对工厂方法模式的升级，工厂方法模式只生产一个等级的产品，而抽象工厂模式能生产多个等级的产品

#### 结构

- 抽象工厂：提供了创阿金产品的接口，包含多个创建产品的方法，可以创建多个不同等级的产品
- 具体工厂：实现抽象工厂中的多个抽象方法，创建具体的产品
- 抽象产品：产品的规范标准，抽象工厂模式下，可以有多个抽象产品
- 具体产品：实现了抽象产品角色所定义的接口，具体工厂来创建具体产品

#### 实现

咖啡店既可以卖咖啡（拿铁咖啡，美式咖啡），也可以卖抹茶慕斯类，提拉米苏类。分类时，不止包括咖啡类和蛋糕类。拿铁咖啡和提拉米苏都是意大利风味 同属于一个产品族，美式咖啡和抹茶慕斯属于美式风味 同属于一个产品族。

![image-20230529165503481](设计模式.assets/image-20230529165503481.png)

抽象工厂

```java
public interface DessertFactory {

    Coffee createCoffee();

    Dessert createDessert();
}
```

具体工厂：

```java
//美式甜点工厂
public class AmericanDessertFactory implements DessertFactory {

    public Coffee createCoffee() {
        return new AmericanCoffee();
    }

    public Dessert createDessert() {
        return new MatchaMousse();
    }
}
//意大利风味甜点工厂
public class ItalyDessertFactory implements DessertFactory {

    public Coffee createCoffee() {
        return new LatteCoffee();
    }

    public Dessert createDessert() {
        return new Tiramisu();
    }
}
```

此时将原本产品类的概念进行了进一步的封装和提取，分为产品族，包含多个产品。若增加新的产品，则创建新的产品族即可。

#### 优缺点

优点

- 在一个产品族中的多个对象被设计成一起调用时，则能保证用户调用的是一个产品族中的对象。（一个产品族工厂获取的对象当然同属于一个产品族了）

缺点

- 产品族若增加新的产品，所有的工厂类都需要更改  （若产品族可能增加了牛排，茶等，那么所有工厂类都需要更改）



#### 使用场景

- 在需要创建的对象是一系列相互关联或者依赖的产品时
- 系统中有多个产品族，但每次使用，只使用其中某一族产品
- 系统中提供了产品的类库，所有产品接口相同，即用户不依赖产品实例的创建细节。 （输入法皮肤，一整套一起换）



















































































































