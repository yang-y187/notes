# 1，设计模式简介

## 设计模式概念

软件设计模式，**代码设计经验的总结**。描述了在软件设计过程中不断发生的问题，以及该问题的解决方案。更多的是对代码设计经验的总结模式，方便套用。 

## 设计模式分类

- 创建型模式
  - 用于描述怎样创建对象，主要特点就是将**对象的创建和使用分离**，包括单例，原型，工厂方法，抽象工厂，建造者，5种模式
- 结构型模式
  -   用于描述如何将类或者对象按某种布局组成更大的结构，代理，适配器，桥接，装饰，外观，享元，组合，7种模式
- 行为型模式
  - 描述类或者对象之间如何相互协作，共同完成单个对象无法单独完成的任务和分配职责。模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器，11种行为型模式。



# 2, UML图

 UML是用于设计软件的可视化统一建模语言。它的特点是简单，统一，图形化，能表达软件设计中的动态和**静态信息**

从设计目标的不同，可以分为：用例图，**类图**，对象图，状态图，活动图，时序图，协作图，构件图，部署图等9种



## 类图的概述

类图显示了模型的静态结构，特别是模型中存在的类，类的内部结构以及它们与其台类的关系等，类图不显示暂时性的信息，类图是面向对象建模的主要组成部分。

## 类图表示

![img](设计模式.assets/v2-5c69cd9ff703377f7bbf37cee8199451_720w.webp)

类图中，类使用包含类名，属性和方法

属性/方法名称前加的加号和减号表示这个属性/方法的可见性，UML类图中表示可见性的符合有三种：

- +：表示public
- -: 表示private
- \#:表示protected

属性的完整表示方式： **可见性 名称 ：类型[ =缺省值]** 

方法的完整表示方式：**可见性 名称（参数列表）[:返回值类型]**

[] 中括号为可有可无的初始化值。 



## 类之间关系的表示方式

- 关联关系
  -   单向关联
  - 双向关联
  - 自关联
- 聚合关系
- 组合关系

### 关联关系

#### 单向关联

在UML类中，用一个带箭头的实线表示，图中表示每个顾客类都持有一个地址类型的成员变量实现

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-3275137.png)

#### 双向关联

双向关联用一个不带箭头的实线表示，两个类中均持有对方类型的成员变量

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230505162807228.png)

#### 自关联

自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是"自己包含自己"。【LinkedList底层用到了自关联】

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230505163303881.png)

### 聚合关系

聚合关系是强关联关系，整体和部分的关系。成员对象是整体对象的一部分，但成员对象可以脱离整体对象而存在。

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230505164318184.png)

### 组合关系

==组合关系表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。==

组合关系中，整体对象可以控制部分的生命周期，一旦整体对象不存在，部分对象不能脱离整体而存在。

在UML类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230508091838682.png)

### 依赖关系

依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，使是临时性的关联。

在代码中，某个类的方法通过局部变量，方法的参数或者静态方法的调用来访问另一个类中的某些方法来完成职责。

**![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230508092618983.png)**

### 继承关系

继承关系是对象之间耦合对最大的一种关系。

在UML类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。

![在这里插入图片描述](设计模式.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjE2NTAz,size_16,color_FFFFFF,t_70-20230508092752689.png)

### 实现关系

实现关系是接口与实现类之间的关系，类实现了接口，类中的操作实现了接口中所声明的所有抽象方法。



# 3，软件设计原则

软件设计中，为了提高软件系统的可维护性和可复用性，增加软件的可拓展性和灵活性，程序员要尽量根据6条原则开发程序，从而提高软件开发效率，节约软件开发成本和维护成本。



## 3.1 开闭原则

**对拓展开放，对修改关闭**。

==程序需要拓展时，不能去修改原有代码，而是实现热插拔的效果。==为了使程序的拓展性好，易于维护和升级。我们使用**接口和抽象类**,因为抽象类灵活性好，适用性广。我们可以通过抽象派生出的实现类来进行拓展。，若需求发生变化，则根据需要派生出一个新的实现类来拓展即可。



## 3.2 里氏代换原则

里氏代换原则是面向对象设计的基本原则之一

里氏代换原则：任何基类可以出现的地方，子类也可出现。可理解为：**子类继承父类时，进行是新增方法，而不是重写父类已有的方法**

子类虽然可以重写父类的方法来完成指定的功能，但整个继承体系的可复用性则会变差，尤其在使用多态频繁的场景。

理解为：重写父方法虽然可完成个别指定的功能，在多态的多场景下，未必完全适用。

## 3.3 依赖倒转原则

高层模块不能依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

**可理解为：对传入参数或者属性选择抽象类或者接口，而不必是具体类，避免无法变更该类，即set属性为学生，但我们类的属性类型应选择人（抽象类），因为可能参数变更为老师**， 类依赖抽象，而不是依赖于具体实现类

## 3.4 接口隔离原则

客户端不应该依赖它不使用的方法，一个类对另一个的依赖应该建立在最小的接口上。

**可理解为：子类A依赖B的方法1，但不依赖B的方法2，所以将方法1，方法2写入两个接口上，A只实现接口1，类B实现接口1,2**，则是一个类对另一个类的依赖应取最小的依赖权限

## 3.5 迪米特原则

迪米特原则：最少知识原则

两个软件实体无须直接通信，那么不应该直接相互调用，可以通过第三方转发该调用。

目的：降低类之间的耦合度，提高模块的相对独立性。

两个软件的关系：当前对象本身，当前对象的成员对象，当前对象所创建的对象，当前对象的方法参数等，这些对象同当前对象存在关联，聚合等关系，可访问这些对象的方法。

**可理解为：万事万物皆对象，需要将某些属性，方法抽成类对象，调用该类对象的属性，方法，而不是直接编写属性，方法**

## 3.6 合成复用原则

尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

通常类的复用分为继承复用和合成复用两种

- **继承复用**：虽然简单和容易实现，但也有一些缺点
  - 继承复用破坏了类的封装性，因为继承会将父类的实现细节暴露给子类，即子类拥有父类的属性和方法
  - 子类和父类耦合度高，父类的实现的任何改变，都会对子类产生影响，不利于类的拓展和维护
  - 它限制了复用的灵活性，从父类继承而来的实现是静态的，编译时已经生成，无法修改
- **组合复用**：将已有对象纳入新对象时，使之成为新对象的一部分，新对象可以抵用已有对象的功能
  - 它维持了类的封装性
  - 对象的耦合度低
  - 复用的灵活性高。（可以属性为父类，抽象类等，传入子类，增加灵活性）



汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： 

![image-20230520120456688](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230520120456688-16845554997623-16845555016495.png)

从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。

![image-20230520120515345](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230520120515345-16845555169317.png)

# 4 创建者模式

创建者模式：主要关注怎样创建对象，将对象的创建和使用分离

创建者模式分为：

- 单例模式
- 工厂方法模式
- 抽象工程模式
- 原型模式
- 建造者模式

## 4.1 单例模式

单例模式分为**饿汉式**和**懒汉式**

- 饿汉式：类加载就会创建该实例类
- 懒汉式：类加载时不会创建单例对象，在首次获取该处对象时，才会被创建

### 单例模式实现方式

#### 饿汉式-方式1（静态变量方式）

```java
/**
 * 饿汉式
 *      静态变量创建类的对象
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance = new Singleton();

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

说明：

该方式通过静态变量，在类加载时创建对象，若对象太大，而一直未使用，则造成内存浪费

#### 饿汉式-方式2（静态代码块方式）

```java
/**
 * 恶汉式
 *      在静态代码块中创建该类对象
 */
public class Singleton {

    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    static {
        instance = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

说明：

与方式1相仿

#### 懒汉式-方式1（线程不安全）

```java
/**
 * 懒汉式
 *  线程不安全
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {

        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

<font color='red'>说明：</font>

线程不安全，在多个线程同时第一次调用该对象时，发现该对象为null，多线程都创建了new singleton，并返回。则创建出了多个singleton

#### 懒汉式-方式2（线程安全）

```java
/**
 * 懒汉式
 *  线程安全
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static synchronized Singleton getInstance() {

        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

<font color='red'>说明：</font>

在获取对象方法上，加synchronized关键字，导致该方法的执行效率低，因为只有在创建对象时，存在线程安全问题，创建完成后，只是读取单例的地址不存在线程安全。所以有性能低的问题

#### 懒汉式-方式3（双重检查锁）

在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。注意需要添加volatile 关键字，来保证可见性和有序性

```java
public final class Singleton {
    private Singleton() { }
        // 问题1：解释为什么要加 volatile ?
        private static volatile Singleton INSTANCE = null;
        // 问题2：对比上个实现, 说出这样做的意义
        public static Singleton getInstance() {
            if (INSTANCE != null) {
            	return INSTANCE;
            }
            synchronized (Singleton.class) {
                // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗
                if (INSTANCE != null) { // t2
                	return INSTANCE;
                }
            INSTANCE = new Singleton();
            return INSTANCE;
        }
    }
}
```

- 问题1：
  - **volatile此时主要是避免因为指令重排而出现的问题**
    - 若创建对象 [INSTANCE = new Singleton()] 出现重排序，先给INSTANCE赋予地址值，但单实例此时没有完全初始化。后续线程进入getInstance方法，因为INSTANCE不为空（第一个判断），会获取到还没有初始化完成的单实例。**单实例有问题**
  - volatile加入了写屏障，使得INSTANCE赋值之前，其他指令已经完成。
  - 保证了可见性
- **问题2：实现3为在单实例获取方法上加synchronized**
  - 避免了已经创建对象，却仍要竞争锁的情况，（影响速度）
- **问题3：**
  - 在INSTANCE为null时，多个线程同时来获取单实例，第一次判断INSTANCE为null。只有一个线程竞争到锁并创建了对象，其他线程也会继续竞争锁，进入synchronized方法，若没有该判断，则会继续创建对象，而不是使用已经创建的对象

#### 懒汉式-方式4（静态内部类方式）

静态内部类单例模式中实例由内部类创建，由于jvm在加载外部类时，不会加载静态内部类，只有内部类的属性/方法被调用时才会被加载，并初始化内部类的静态属性。而且静态属性因为static修饰，属于类，只初始化一次，保证了实例化顺序

```java
/**
 * 静态内部类方式
 */
public class Singleton {

    //私有构造方法
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

<font color='red'>说明：</font>

 第一次加载Singleton类时，不会初始化单例对象，只有在第一次调用getInstance方法时，虚拟机才加载内部类，并初始化，既保证了线程安全，又保证了唯一性。（因为类加载只加载一次）

<font color="red">小结：</font>

**静态内部类单例模式是一种优秀的单例模式，而且非常常见，没有加锁，既保证了线程安全，又没有性能和空间的浪费。**

#### 枚举方式

**枚举类单例模式是线程安全的，并且只会被加载一次，枚举的写法简单，并且唯一不会被破坏的单例实现模式**

```java
/**
 * 枚举方式
 */
public enum Singleton {
    INSTANCE;
}
```

<font color='red'>说明：</font>

 枚举属于饿汉式

### 单例设计模式问题

单例被破坏的方法：**序列化反序列化和反射**，但枚举方式的单例不会被这两个破坏。

- #### 反序列化破坏单例模式解决方案

在单例类Singleton中，添加`readResolve()`方法，在反序列时被反射调用，如果定义了这个方法，就返回该方法的返回值，如果没有定义，则通过反射new一个新的对象

```java
public class Singleton implements Serializable {

    //私有构造方法
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
    
    /**
     * 下面是为了解决序列化反序列化破解单例模式
     */
    private Object readResolve() {
        return SingletonHolder.INSTANCE;
    }
}
```



源码解析：

ObjectInputStream类

```java
public final Object readObject() throws IOException, ClassNotFoundException{
    ...
    // if nested read, passHandle contains handle of enclosing object
    int outerHandle = passHandle;
    try {
        Object obj = readObject0(false);//重点查看readObject0方法
    .....
}
    
private Object readObject0(boolean unshared) throws IOException {
	...
    try {
		switch (tc) {
			...
			case TC_OBJECT:
				return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法
			...
        }
    } finally {
        depth--;
        bin.setBlockDataMode(oldMode);
    }    
}
    
private Object readOrdinaryObject(boolean unshared) throws IOException {
	...
	//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，
    obj = desc.isInstantiable() ? desc.newInstance() : null; 
    ...
    // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true
    if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) {
    	// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量
    	// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。
    	Object rep = desc.invokeReadResolve(obj);
     	...
    }
    return obj;
}
```

- #### 反射破坏单例模式解决方案

  ```java
  public class Singleton {
  
      //私有构造方法
      private Singleton() {
          /*
             反射破解单例模式需要添加的代码
          */
          if(instance != null) {
              throw new RuntimeException();
          }
      }
      
      private static volatile Singleton instance;
  
      //对外提供静态方法获取该对象
      public static Singleton getInstance() {
  
          if(instance != null) {
              return instance;
          }
  
          synchronized (Singleton.class) {
              if(instance != null) {
                  return instance;
              }
              instance = new Singleton();
              return instance;
          }
      }
  }
  ```

  <font color="red">说明:</font>

  破坏单例的创建，不允许通过反射创建多个对象。

### JDK源码中的单例模式

Runtime类使用饿汉式（静态属性）单例设计模式

```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    /**
     * Returns the runtime object associated with the current Java application.
     * Most of the methods of class <code>Runtime</code> are instance
     * methods and must be invoked with respect to the current runtime object.
     *
     * @return  the <code>Runtime</code> object associated with the current
     *          Java application.
     */
    public static Runtime getRuntime() {
        return currentRuntime;
    }

    /** Don't let anyone else instantiate this class */
    private Runtime() {}
    ...
}
```

## 4.2 工厂模式

java中，万物皆对象，对象创建需要new对象，耦合眼红，如果更改对象，需要将所有new对象的位置都改。未被了软件设计的开闭原则。因此，我们选择工厂来生产对象，使用对象，只从工厂获取，如果更换对象，在工厂内更换，达到对象解耦的目的。工厂模式的最大优点：**解耦**

工厂模式：

- 简单工厂模式 (不是设计模式，更像是一种编程习惯)
- 工厂方法模式
- 抽象工厂模式

### 简单工厂模式

简单工厂不是设计模式，更多的像是一种编程习惯。开发过程中，很多奖工厂类里的创建对象功能设为静态的static，即静态工厂模式，此模式也是开发习惯，而非设计模式

简单工厂提供的角色：

- 抽象产品：定义了对象的基本规范，描述了主要特性
- 具体产品：实现或者继承类的子类
- 具体工厂：提供了创建对象的方法，调用者通过该方法获取想要的对象



对象的创建和使用分开。创建对象，根据传参在SimpleFactory中创建各种对象，使用对象时，从SimpleFactory中获取。解除了调用方与对象实现类的耦合。但产生了新的耦合。对象和生产对象的工厂的耦合，工厂对象和产品对象的耦合。

如果后期添加新的产品对象，仍需要更改工厂对象的代码，违反了开闭原则。

#### 实现

```java
public class SimpleCoffeeFactory {

    public Coffee createCoffee(String type) {
        Coffee coffee = null;
        if("americano".equals(type)) {
            coffee = new AmericanoCoffee();
        } else if("latte".equals(type)) {
            coffee = new LatteCoffee();
        }
        return coffee;
    }
}
```

#### 优缺点

##### **优点：**

封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑分开。在以后有新对象创建时，不必更改原有代码，只更改工厂类即可。容易拓展

##### 缺点：

新增产品对象后，仍需要更改工厂类对象，违背了开闭原则



### 模式拓展

简单工厂+配置文件解除耦合

通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合，具体实现是在工厂类中加载配置文件中全类名，创建对象并存储到map中，客户端如果需要对象，则可以直接获取。

#### 一 定义配置文件

```properties
american=com.itheima.pattern.factory.config_factory.AmericanCoffee
latte=com.itheima.pattern.factory.config_factory.LatteCoffee
```

#### 二 工厂类 

```java
public class CoffeeFactory {

    private static Map<String,Coffee> map = new HashMap();

    static {
        Properties p = new Properties();
        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream("bean.properties");
        try {
            p.load(is);
            //遍历Properties集合对象
            Set<Object> keys = p.keySet();
            for (Object key : keys) {
                //根据键获取值（全类名）
                String className = p.getProperty((String) key);
                //获取字节码对象
                Class clazz = Class.forName(className);
                Coffee obj = (Coffee) clazz.newInstance();
                map.put((String)key,obj);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static Coffee createCoffee(String name) {

        return map.get(name);
    }
}
```

静态代码段，表示只需要执行一次，并存储在静态变量map中



### 工厂方法模式

简单工厂模式在新增产品对象后，仍需要更改工厂类对象，违背开闭原则。该工厂方法模式可以完美解决。

#### 概念

定义了一个创建对象的接口，该子类决定实例化哪个产品对象，该工厂方法使产品的实例化延迟到该工厂的子类中。

#### 结构：

- 抽象工厂：提供工厂的抽象类或者接口标准，可调用该类的具体实现创建产品
- 具体工厂：实现抽象工厂的抽象方法，完成具体产品的创建
- 抽象产品：定义了产品的规范，包括特性和功能
- 具体产品：实现了抽象产品所定义的接口，由具体工厂进行创建

#### 实现

![image-20230529100138030](设计模式.assets/image-20230529100138030.png)

代码如下：

抽象工厂：

```java
public interface CoffeeFactory {

    Coffee createCoffee();
}
```

具体工厂：

```java
public class LatteCoffeeFactory implements CoffeeFactory {

    public Coffee createCoffee() {
        return new LatteCoffee();
    }
}

public class AmericanCoffeeFactory implements CoffeeFactory {

    public Coffee createCoffee() {
        return new AmericanCoffee();
    }
}
```

**咖啡店类：**

```java
public class CoffeeStore {

    private CoffeeFactory factory;

    public CoffeeStore(CoffeeFactory factory) {
        this.factory = factory;
    }

    public Coffee orderCoffee(String type) {
        Coffee coffee = factory.createCoffee();
        coffee.addMilk();
        coffee.addsugar();
        return coffee;
    }
}
```

在该模式下，若增加新的产品类，不需要更改工厂类对象，只需要创建新的工厂类，并作为参数传入该对象。

#### 优缺点

**优点**

- 用户只需要知道具体工厂的名称就可以获取产品，调用方与产品对象的创建隔离
- 新增产品时，只需要增加具体的产品类和工厂类，无需更改原有代码，满足开闭原则（不更改已有的业务代码）

缺点：

- 每增加一个产品，都需要增加一个具体的产品类和工厂类，增加了系统复杂度



### 抽象工厂模式

工厂方法模式中，工厂只考虑一类产品生产，但很多时候，一个具体工厂可能生产多种同级产品，比如苹果工厂生产手机，电脑，耳机等。此时，需要抽象工厂模式进行实现

#### 概念

为访问类提供一个创建一组或相互依赖对象的接口，且访问类没有指定所要产品的具体类，就能得到该产品

抽象工厂模式是对工厂方法模式的升级，工厂方法模式只生产一个等级的产品，而抽象工厂模式能生产多个等级的产品

#### 结构

- 抽象工厂：提供了创阿金产品的接口，包含多个创建产品的方法，可以创建多个不同等级的产品
- 具体工厂：实现抽象工厂中的多个抽象方法，创建具体的产品
- 抽象产品：产品的规范标准，抽象工厂模式下，可以有多个抽象产品
- 具体产品：实现了抽象产品角色所定义的接口，具体工厂来创建具体产品

#### 实现

咖啡店既可以卖咖啡（拿铁咖啡，美式咖啡），也可以卖抹茶慕斯类，提拉米苏类。分类时，不止包括咖啡类和蛋糕类。拿铁咖啡和提拉米苏都是意大利风味 同属于一个产品族，美式咖啡和抹茶慕斯属于美式风味 同属于一个产品族。

![image-20230529165503481](设计模式.assets/image-20230529165503481.png)

抽象工厂

```java
public interface DessertFactory {

    Coffee createCoffee();

    Dessert createDessert();
}
```

具体工厂：

```java
//美式甜点工厂
public class AmericanDessertFactory implements DessertFactory {

    public Coffee createCoffee() {
        return new AmericanCoffee();
    }

    public Dessert createDessert() {
        return new MatchaMousse();
    }
}
//意大利风味甜点工厂
public class ItalyDessertFactory implements DessertFactory {

    public Coffee createCoffee() {
        return new LatteCoffee();
    }

    public Dessert createDessert() {
        return new Tiramisu();
    }
}
```

此时将原本产品类的概念进行了进一步的封装和提取，分为产品族，包含多个产品。若增加新的产品，则创建新的产品族即可。

#### 优缺点

优点

- 在一个产品族中的多个对象被设计成一起调用时，则能保证用户调用的是一个产品族中的对象。（一个产品族工厂获取的对象当然同属于一个产品族了）

缺点

- 产品族若增加新的产品，所有的工厂类都需要更改  （若产品族可能增加了牛排，茶等，那么所有工厂类都需要更改）



#### 使用场景

- 在需要创建的对象是一系列相互关联或者依赖的产品时
- 系统中有多个产品族，但每次使用，只使用其中某一族产品
- 系统中提供了产品的类库，所有产品接口相同，即用户不依赖产品实例的创建细节。 （输入法换皮肤，一整套一起换）



### jdk源码解析

 

```java
public class Demo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("令狐冲");
        list.add("风清扬");
        list.add("任我行");

        //获取迭代器对象
        Iterator<String> it = list.iterator();
        //使用迭代器遍历
        while(it.hasNext()) {
            String ele = it.next();
            System.out.println(ele);
        }
    }
}
```

迭代器遍历集合，获取集合中的元素，获取迭代器的方法则用到了工厂方法模式：

![image-20230530165751067](设计模式.assets/image-20230530165751067.png)

Collection接口是抽象工厂类，ArrayList是具体的工厂类，创建iter()对象。Iterator类是抽象的商品类，ArrayList类中的iter内部类是具体的商品类，在具体的工厂类ArrayList中，调用iterator()方法，创建具体的商品类iter对象

```java
    /**
     * Returns an iterator over the elements in this list in proper sequence.
     *
     * <p>The returned iterator is <a href="#fail-fast"><i>fail-fast</i></a>.
     *
     * @return an iterator over the elements in this list in proper sequence
     */
    public Iterator<E> iterator() {
        return new Itr();
    }
```



## 4.3 原型模式

#### 概述

用一个已经创建的实例作为模型，通过复制来创建一个和原型对象相同的新对象

#### 结构

- 抽象原型类：具体原型对象必须实现的clone方法
- 具体原型类：实现了抽象原型类的方法，可通过该对象进行复制
- 访问类：使用具体原型类中的clone方法复制新对象



![原型模式](设计模式.assets/原型模式-5438532.png)



#### 实现

原型模式的克隆分为浅克隆和深克隆

> 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
>
> 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

![image-20230530172517290](设计模式.assets/image-20230530172517290.png)

##  4.5 建造者模式

### 概述

工厂模式侧重于对象的创建，而建造者模式侧重与对复杂对象的组织  

将一个复杂对象构建和表示分离开，使得同样的构建过程能够创建不同的表示。

- 分离了部件的构造和装配，可以构建出复杂的对象。 **该模式适用于某个对象的创建过程十分复杂**
- 完成了构建对象和表示解耦，不同的构造器，相同的装配，可以是不同的对象；相同的构造器，不同的装配顺序，也可以构造不同的对象。
- 构造者模式，用户提供材料即可，不需要知道具体的构造细节

### 结构

建造者模式包括如下：

- 抽象构建者类：该接口规定了创建复杂对象哪些部分的创建
- 具体构建者类：实现了Builder接口，完成了复杂产品的各个部件的具体构建方法。构建完成后，提供产品实例
- 产品类：要创建的复杂对象
- 指挥者类：调用具体构建者创建复杂对象的各个部分，指挥者不涉及具体的创建工作，而只是保证构建对象的完整和顺序。

![image-20230530183700027](设计模式.assets/image-20230530183700027.png)

### 实例

生产自行车是复杂过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。

Bike为产品，Builder为抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者（指定构建顺序和获取Bike产品）

![image-20230530210025087](设计模式.assets/image-20230530210025087.png)

```java
//自行车类
public class Bike {
    private String frame;
    private String seat;

    public String getFrame() {
        return frame;
    }

    public void setFrame(String frame) {
        this.frame = frame;
    }

    public String getSeat() {
        return seat;
    }

    public void setSeat(String seat) {
        this.seat = seat;
    }
}

// 抽象 builder 类
public abstract class Builder {

    protected Bike mBike = new Bike();

    public abstract void buildFrame();
    public abstract void buildSeat();
    public abstract Bike createBike();
}

//摩拜单车Builder类
public class MobikeBuilder extends Builder {

    @Override
    public void buildFrame() {
        mBike.setFrame("铝合金车架");
    }

    @Override
    public void buildSeat() {
        mBike.setSeat("真皮车座");
    }

    @Override
    public Bike createBike() {
        return mBike;
    }
}

//ofo单车Builder类
public class OfoBuilder extends Builder {

    @Override
    public void buildFrame() {
        mBike.setFrame("碳纤维车架");
    }

    @Override
    public void buildSeat() {
        mBike.setSeat("橡胶车座");
    }

    @Override
    public Bike createBike() {
        return mBike;
    }
}

//指挥者类
public class Director {
    private Builder mBuilder;

    public Director(Builder builder) {
        mBuilder = builder;
    }

    public Bike construct() {
        mBuilder.buildFrame();
        mBuilder.buildSeat();
        return mBuilder.createBike();
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        showBike(new OfoBuilder());
        showBike(new MobikeBuilder());
    }
    private static void showBike(Builder builder) {
        Director director = new Director(builder);
        Bike bike = director.construct();
        System.out.println(bike.getFrame());
        System.out.println(bike.getSeat());
    }
}
```

### **优缺点**：

**优点：**

- 建造者模式的封装性很好。在建造者模式下，一般产品类和建造者者是比较稳定的，新的业务逻辑封装在指挥者类中，对整体而言可以有很好的稳定性。**即建造者和产品类是不变的，或者变化很小时，可以选择建造者类**
- 建造者模式下，创建对象和调用解耦，并且创建过程相同，可能创建不同的对象
- 对产品的分步骤创建，使得创建过程清晰，且容易控制
- 建造者模式容易拓展，若有新的需求，则创建新的建造者类即可。不修改原有代码，符合开闭原则

**缺点**

建造者模式创建的产品需要有较多共同点，组成部分相似，若产品之间的差异性较大，则无法使用建造者模式。



### 使用场景

建造者创建的对象十分复杂，而产品的各个部分经常发生较大变化。但创建过程却很固定（相对稳定），则可以使用建造者模式

- 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。
- 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。



### 模式拓展

 建造者模式：我们目前的BPaas就是建造者模式，不允许直接创建该类对象，而是通过传参builder，来创建我们想要的对象。若参数过多，则直接创建该对象，代码可读性很差，因为构造器包含所有参数，创建时传入过多参数，可读性太差，而且很容易引入错误。

**通过构造者模式重建**，将原本的直接创建该对象，改为传入参数才能创建对象。提高可读性，还能链式编程。



```java
public class Phone {

    private String cpu;
    private String screen;
    private String memory;
    private String mainboard;

    private Phone(Builder builder) {
        cpu = builder.cpu;
        screen = builder.screen;
        memory = builder.memory;
        mainboard = builder.mainboard;
    }

    public static final class Builder {
        private String cpu;
        private String screen;
        private String memory;
        private String mainboard;

        public Builder() {}

        public Builder cpu(String val) {
            cpu = val;
            return this;
        }
        public Builder screen(String val) {
            screen = val;
            return this;
        }
        public Builder memory(String val) {
            memory = val;
            return this;
        }
        public Builder mainboard(String val) {
            mainboard = val;
            return this;
        }
        public Phone build() {
            return new Phone(this);}
    }
    @Override
    public String toString() {
        return "Phone{" +
                "cpu='" + cpu + '\'' +
                ", screen='" + screen + '\'' +
                ", memory='" + memory + '\'' +
                ", mainboard='" + mainboard + '\'' +
                '}';
    }
}

public class Client {
    public static void main(String[] args) {
        Phone phone = new Phone.Builder()
                .cpu("intel")
                .mainboard("华硕")
                .memory("金士顿")
                .screen("三星")
                .build();
        System.out.println(phone);
    }
}
```



## 4.6 创建者模式对比

### 工厂方法模式VS建造者模式

工厂方法模式注重的是整体对象的创建过程，建造者模式注重的是部件创建过程，旨在通过一步一步地精确的创建出一个复杂的对象。

工厂模式：创建对象更多的是直接生产该对象，建造者模式则是组装各个部件。

### 抽象工厂模式vs建造者模式

抽象工厂模式实现对产品族的创建，目的是一个系列的产品。抽象者模式不需要关心构建过程，只关心什么产品由哪个具体的工厂创建

建造者仍然是通过组装零件创建传完整的对象。

抽象工厂可以看成是一个品牌的汽车工厂，比如奔驰，特斯拉。只造一个品牌的汽车。而建造者模式则是一个组装工厂，而轮胎，车架，发动机等进行组装。



# 5 结构型模式

 结构型模式通过类和对象构建某种结构。分为

1. 类结构型模式：通过继承机制组织接口和类
2. 对象结构型模式：：通过组合或聚合组合对象



组合和聚合关系比继承关系耦合度低，满足合成复用原则，具有更多的灵活性

结构型模式分为7种：

- 代理模式
- 适配器模式
- 装饰者模式
- 桥接模式
- 外观模式
- 组合模式
- 享元模式

## 5.1 代理模式

### 概述

给某个对象提供一个代理进行对该对象的访问，即中介。访问对象不适合或者不能直接引用该目标对象，代理对象作为访问对象和目标对象的中介。

java中的代理分为

1. 静态代理
2. 动态代理

静态代理在编译期就生成代码，而动态代理则是在java运行时动态生成，动态代理分为jdk自带的代理方式和cglib代理两种。

### 结构

代理分为三种角色

- 抽象主题：通过接口或抽象类声明真实主题
- 真实主题：实现了抽象主题中的具体业务，是代理对象的真实对象，是最终引用的对象
- 代理类：提供了接口，内部包含对真实主题的引用，它可以访问，控制或拓展真是主题的功能

### 静态代理

与static没有任何关系，而是将代码写死，以车站卖车票为例，可以有多个代理点来卖车票。多个代理点则是代理对象，车站是目标对象。创建一个新的对象，内部其中一个属性是真实类，在调用方法前后进行自定义逻辑。这种方式对象是固定的。

```java
//卖票接口
public interface SellTickets {
    void sell();
}

//火车站  火车站具有卖票功能，所以需要实现SellTickets接口
public class TrainStation implements SellTickets {

    public void sell() {
        System.out.println("火车站卖票");
    }
}

//代售点
public class ProxyPoint implements SellTickets {

    private TrainStation station = new TrainStation();

    public void sell() {
        System.out.println("代理点收取一些服务费用");
        station.sell();
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        ProxyPoint pp = new ProxyPoint();
        pp.sell();
    }
}
```



### JDK动态代理

**动态代理的含义是：在代码运行过程中，在内存中动态的生成代理类**，而并不是一个实体类，也可以理解为动态代理没有可以查看的代理类，只有读取内存才能读取。 

jdk中提供了Proxy动态代理类 ，proxy虽然是一个类，但并不是代理类，而是提供了静态方法，可以创建代理对象（newProxyInstance方法）来获取代理对象。

```java
//卖票接口
public interface SellTickets {
    void sell();
}

//火车站  火车站具有卖票功能，所以需要实现SellTickets接口
public class TrainStation implements SellTickets {

    public void sell() {
        System.out.println("火车站卖票");
    }
}

//代理工厂，用来创建代理对象
public class ProxyFactory {

    private TrainStation station = new TrainStation();

    public SellTickets getProxyObject() {
        //使用Proxy获取代理对象
        /*
            newProxyInstance()方法参数说明：
                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可
                Class<?>[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口
                InvocationHandler h ： 代理对象的调用处理程序
         */
        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),
                station.getClass().getInterfaces(),
                new InvocationHandler() {
                    /*
                        InvocationHandler中invoke方法参数说明：
                            proxy ： 代理对象
                            method ： 对应于在代理对象上调用的接口方法的 Method 实例
                            args ： 代理对象调用接口方法时传递的实际参数
                     */
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

                        System.out.println("代理点收取一些服务费用(JDK动态代理方式)");
                        //执行真实对象
                        Object result = method.invoke(station, args);
                        return result;
                    }
                });
        return sellTickets;
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        //获取代理对象
        ProxyFactory factory = new ProxyFactory();
        
        SellTickets proxyObject = factory.getProxyObject();
        proxyObject.sell();
    }
}
```



:warning:ProxyFactory不是代理模式下的代理类，代理类是程序运行过程中在内存动态生成的类。也就是说该类没有暴露出来，只保存在内存中。有阿里的插件可能获取内存内的类，内部结构如下

- 代理类（$Proxy0）实现了与真实类相同的接口， 其构造器传入了通过Proxy.newProxyInstance创建对象时的InvocationHandler接口的实现类（上面例子是匿名实现类） 
- 调用方通过代理对象调用代理类的方法sell方法，其内部调用了InvocationHandler接口中的invoke方法
- invoke通过反射执行真实类中的sell方法

```java
package com.sun.proxy;

import com.itheima.proxy.dynamic.jdk.SellTickets;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy implements SellTickets {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;

    public $Proxy0(InvocationHandler invocationHandler) {
        super(invocationHandler);
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
            m3 = Class.forName("com.itheima.proxy.dynamic.jdk.SellTickets").getMethod("sell", new Class[0]);
            m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
            return;
        }
        catch (NoSuchMethodException noSuchMethodException) {
            throw new NoSuchMethodError(noSuchMethodException.getMessage());
        }
        catch (ClassNotFoundException classNotFoundException) {
            throw new NoClassDefFoundError(classNotFoundException.getMessage());
        }
    }

    public final boolean equals(Object object) {
        try {
            return (Boolean)this.h.invoke(this, m1, new Object[]{object});
        }
        catch (Error | RuntimeException throwable) {
            throw throwable;
        }
        catch (Throwable throwable) {
            throw new UndeclaredThrowableException(throwable);
        }
    }

    public final String toString() {
        try {
            return (String)this.h.invoke(this, m2, null);
        }
        catch (Error | RuntimeException throwable) {
            throw throwable;
        }
        catch (Throwable throwable) {
            throw new UndeclaredThrowableException(throwable);
        }
    }

    public final int hashCode() {
        try {
            return (Integer)this.h.invoke(this, m0, null);
        }
        catch (Error | RuntimeException throwable) {
            throw throwable;
        }
        catch (Throwable throwable) {
            throw new UndeclaredThrowableException(throwable);
        }
    }

    public final void sell() {
        try {
            this.h.invoke(this, m3, null);
            return;
        }
        catch (Error | RuntimeException throwable) {
            throw throwable;
        }
        catch (Throwable throwable) {
            throw new UndeclaredThrowableException(throwable);
        }
    }
}
```



### CGLIB动态代理

CGLIb是一个功能强大的代码生成包，也是在内存中生成代理类，**在被代理类没有实现接口时，可以通过CGLIB完成代理**。

```java
//火车站
public class TrainStation {

    public void sell() {
        System.out.println("火车站卖票");
    }
}

//代理工厂
public class ProxyFactory implements MethodInterceptor {

    private TrainStation target = new TrainStation();

    public TrainStation getProxyObject() {
        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数
        Enhancer enhancer =new Enhancer();
        //设置父类的字节码对象
        enhancer.setSuperclass(target.getClass());
        //设置回调函数
        enhancer.setCallback(this);
        //创建代理对象
        TrainStation obj = (TrainStation) enhancer.create();
        return obj;
    }

    /*
        intercept方法参数说明：
            o ： 代理对象
            method ： 真实对象中的方法的Method实例
            args ： 实际参数
            methodProxy ：代理对象中的方法的method实例
     */
    public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println("代理点收取一些服务费用(CGLIB动态代理方式)");
        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);
        return result;
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        //创建代理工厂对象
        ProxyFactory factory = new ProxyFactory();
        //获取代理对象
        TrainStation proxyObject = factory.getProxyObject();

        proxyObject.sell();
    }
}
```



### 三种代理对比

- jdk代理和cglib代理
  - 使用cglib实现动态代理，底层使用AMS字节码生成框架，使用字节码生成技术生成代理类，在jdk1.6之前，比使用java反射效率要高，由于jdk的不断优化，现在jdk动态代理性能要强于cglib。即实现了接口，则使用jdk代理，没实现则使用cglib代理
  - **cglib不能对声明为final的类或者方法进行代理，因为cglib实际是动态生成被代理类的子类**
- 动态代理和静态代理
  - 动态代理和静态代理相比较，都统一由InvocationHandler.invoke 集中处理，在接口比较多的情况下，可以灵活一点，静态代理，则需要对每个方法进行中转
  - 若接口实现了一个方法，静态代理模式下，所有的实现类都需要实现该方法，并且所有代理类也需要实现该方法，动态代理不需要。

### 优缺点

- ### 优点

  - 代理模式在调用方和目标对象之间添加了一层，保护目标对象，并在一定程度上进行了解耦

  - 代理对象可以对目标对象进行拓展，比如代理对象执行目标对象之前，收取手续费等信息

- ### 缺点

  - 增加了系统的复杂度



### 使用场景

- 远程调用 RPC
  - 本地服务通过网络请求远程服务，此时需要网络通信，通过代理模式将通信部分隐藏，只暴露本地服务接口，通过该接口就可以访问远程服务提供的功能，而不必要关心通信细节，提高了可维护性
- 防火墙代理 VPN
  - 游览器配置为代理功能时，防火墙则将游览器的请求转发给互联网，互联网返回响应时，代理模式再转给游览器
- 保护代理 
  - 控制对一个对象的访问，如果需要，可以给不同的用户不同的访问权限。（我们通过给代理对象设置级别，从而完成分级权限）



## 5.2 适配器模式

适配器模式

### 概述

适配器将一个类的接口转换为可以为调用方提供服务的接口，使得原本不兼容的可以一起工作。

分为类适配器模式和对象适配器模式。前者耦合度比比后者高，因为是通过继承的方式实现，且要求了解内部结构，应用较少。后者是通过组合的方式。

### 结构

适配器模式包好一下角色

- 目标接口：当前系统业务期待的接口，可以是抽象类或者接口
- 适配者类：实际被访问的类
- 适配器类：为转换器，调用方通过该类访问目标适配者。其内部将是配置接口转换为目标接口，让调用方通过该接口进行访问

### 类适配器模式

定义一个适配器类实现当前系统的目标接口，通过该接口完成目标功能。，同时又**继承**被适配的类，类适配器本身需要通过继承来实现。

**类适配器模式违背了合成复用原则，类适配器需要在目标类有接口规范的情况下使用，否则不可使用**

合成复用原则：要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

【例】

电脑只能读取内存卡，而读取TF卡中的内容，则需要通过读卡器实现，读卡器则可以理解为适配器。此时读卡器既能读内存卡的内容，也能读TF卡的内容。

明确概念：TF卡是内存卡的一种，而不是两种卡

以读卡器为例：

![image-20230618094805202](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230618094805202.png)

- SD卡读取为接口（内存卡的统一读取标准，TF的读取也要满足该标准），电脑读取时，通过传入参数为SD卡的实现类进行读取。

- 而TF卡不能直接被电脑读取，则TF读取为也是一接口，则该接口的实现类能够读取TF卡
- 适配器类，继承了TF卡的实现类，又实现了SD卡读取接口，能够实现TF卡的读取。
- 此时电脑的读取，则是通过传入的参数判断是普通SD卡，还是TF卡，但通过该适配器既拥有SD卡的读取标准（SD读取接口），又完成TF卡的读取。



【为什么不是实现TF读取接口，而是继承TF接口实现类呢？】

因为适配器仅仅是作为一个适配器，不对目标功能进行改变，而是通过适配器可以访问目标类。现在仅仅是不能直接访问，而不是没有该部分功能，所以是继承，不是实现接口完成该功能。



```java
//SD卡的接口
public interface SDCard {
    //读取SD卡方法
    String readSD();
    //写入SD卡功能
    void writeSD(String msg);
}

//SD卡实现类
public class SDCardImpl implements SDCard {
    public String readSD() {
        String msg = "sd card read a msg :hello word SD";
        return msg;
    }

    public void writeSD(String msg) {
        System.out.println("sd card write msg : " + msg);
    }
}

//电脑类
public class Computer {

    public String readSD(SDCard sdCard) {
        if(sdCard == null) {
            throw new NullPointerException("sd card null");
        }
        return sdCard.readSD();
    }
}

//TF卡接口
public interface TFCard {
    //读取TF卡方法
    String readTF();
    //写入TF卡功能
    void writeTF(String msg);
}

//TF卡实现类
public class TFCardImpl implements TFCard {

    public String readTF() {
        String msg ="tf card read msg : hello word tf card";
        return msg;
    }

    public void writeTF(String msg) {
        System.out.println("tf card write a msg : " + msg);
    }
}

//定义适配器类（SD兼容TF）
public class SDAdapterTF extends TFCardImpl implements SDCard {

    public String readSD() {
        System.out.println("adapter read tf card ");
        return readTF();
    }

    public void writeSD(String msg) {
        System.out.println("adapter write tf card");
        writeTF(msg);
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        Computer computer = new Computer();
        SDCard sdCard = new SDCardImpl();
        System.out.println(computer.readSD(sdCard));

        System.out.println("------------");

        SDAdapterTF adapter = new SDAdapterTF();
        System.out.println(computer.readSD(adapter));
    }
}
```



### 对象适配器模式

将已经实现的功能引入到适配器类中，该类同时实现目标接口。即作为适配器中的一个属性存在



![image-20230618160047059](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230618160047059.png)

适配器传入属性TF接口实现类，

```java
//创建适配器对象（SD兼容TF）
public class SDAdapterTF  implements SDCard {

    private TFCard tfCard;

    public SDAdapterTF(TFCard tfCard) {
        this.tfCard = tfCard;
    }

    public String readSD() {
        System.out.println("adapter read tf card ");
        return tfCard.readTF();
    }

    public void writeSD(String msg) {
        System.out.println("adapter write tf card");
        tfCard.writeTF(msg);
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        Computer computer = new Computer();
        SDCard sdCard = new SDCardImpl();
        System.out.println(computer.readSD(sdCard));

        System.out.println("------------");

        TFCard tfCard = new TFCardImpl();
        SDAdapterTF adapter = new SDAdapterTF(tfCard);
        System.out.println(computer.readSD(adapter));
    }
}
```



还有接口适配器模式，当不希望实现接口所有方法时，则可以创建一个抽象类Adapter，实现该接口，并重写所有方法（未必真正重写该方法），然后继承该类，重写自己需要的方法。



### 应用场景

- 旧系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。根据开闭原则，尽量不修改原有代码，因此新建一个适配器，进行转换
- 使用第三方提供的组件，但组件接口定义和自己定义的接口定义不同

### JDK源码解析



Reader （字符流）、InputStream（字节流）的适配使用的是InputStreamReader。InputStreamReader继承了java.io包中的Reader，对方法进行了实现，并且有传入参数对象 sun.nio.cs.StreamDecoder，该对象仅仅是对InputStream进行封装，

InputStreamReader 源码 

其中的sd为StreamDecoder

```java
public int read() throws IOException {
    return sd.read();
}

public int read(char cbuf[], int offset, int length) throws IOException {
    return sd.read(cbuf, offset, length);
}
```

![image-20230618162310028](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230618162310028.png)

Reader是java SE API中的内容，而StreamDecoder是Sun JDK的内容，所以二者接口不兼容。

通过InputStreamReader对StreamDecoder的封装，可以进行字节流和字符流之间的转换。

<font color="red">结论：</font>

从表面功能看是InputStreamReader进行了字节流到字符流的转换，而继承关系来看，是StreamDecoder的设计实现了对象适配器模式。

## 5.3 装饰者模式

### 概述

快餐店有炒饼，炒面，还可以加鸡蛋，火腿等配菜，若通过继承的方式，那么是成倍增加的，因为加鸡蛋，要定义子类，加鸡蛋火腿还要定义子类，拓展性太差，而且会有很多子类，不易维护

**定义**：

不改变现有对象结构的情况下，动态的给该对象增加一些职责（或者额外的功能）的模式



### 结构

装饰者模式的结构

- 抽象构件角色：定义一个抽象接口来规范准备接收附加功能的对象  （接收附加功能对象的规范）
- 具体构件角色：实现抽象构件角色，通过装饰角色添加功能   
- 抽象装饰角色：继承或实现抽象构件，并包含具体构件的实例，通过其子类拓展具体构件的功能
- 具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任



### 案例

![image-20230618190053100](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20230618190053100.png)

抽象类：快餐，具体实例类包括：炒米，炒面。

抽象类：配料，加配菜。该抽象类继承了快餐抽象类，具体实现类包括鸡蛋，培根。 该类中有具体的金额计算方法，即实际操作在该抽象类中。

配料的具体实现类则是将原来快餐类的信息传入进去，即进行赋值。

```java
//快餐接口
public abstract class FastFood {
    private float price;
    private String desc;

    public FastFood() {
    }

    public FastFood(float price, String desc) {
        this.price = price;
        this.desc = desc;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    public float getPrice() {
        return price;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public abstract float cost();  //获取价格
}

//炒饭
public class FriedRice extends FastFood {

    public FriedRice() {
        super(10, "炒饭");
    }

    public float cost() {
        return getPrice();
    }
}

//炒面
public class FriedNoodles extends FastFood {

    public FriedNoodles() {
        super(12, "炒面");
    }

    public float cost() {
        return getPrice();
    }
}

//配料类
public abstract class Garnish extends FastFood {

    private FastFood fastFood;

    public FastFood getFastFood() {
        return fastFood;
    }

    public void setFastFood(FastFood fastFood) {
        this.fastFood = fastFood;
    }

    public Garnish(FastFood fastFood, float price, String desc) {
        super(price,desc);
        this.fastFood = fastFood;
    }
}

//鸡蛋配料
public class Egg extends Garnish {

    public Egg(FastFood fastFood) {
        super(fastFood,1,"鸡蛋");
    }

    public float cost() {
        return getPrice() + getFastFood().getPrice();
    }

    @Override
    public String getDesc() {
        return super.getDesc() + getFastFood().getDesc();
    }
}

//培根配料
public class Bacon extends Garnish {

    public Bacon(FastFood fastFood) {

        super(fastFood,2,"培根");
    }

    @Override
    public float cost() {
        return getPrice() + getFastFood().getPrice();
    }

    @Override
    public String getDesc() {
        return super.getDesc() + getFastFood().getDesc();
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        //点一份炒饭
        FastFood food = new FriedRice();
        //花费的价格
        System.out.println(food.getDesc() + " " + food.cost() + "元");

        System.out.println("========");
        //点一份加鸡蛋的炒饭
        FastFood food1 = new FriedRice();

        food1 = new Egg(food1);
        //花费的价格
        System.out.println(food1.getDesc() + " " + food1.cost() + "元");

        System.out.println("========");
        //点一份加培根的炒面
        FastFood food2 = new FriedNoodles();
        food2 = new Bacon(food2);
        //花费的价格
        System.out.println(food2.getDesc() + " " + food2.cost() + "元");
    }
}
```















































