# 前言 ZNode

Paxos描述了这样一个场景，有一个叫做Paxos的小岛(Island)上面住了一批居民，岛上面所有的事情由一些特殊的人决定，他们叫做议员(Senator)。议员的总数(Senator Count)是确定的，不能更改。岛上每次环境事务的变更都需要通过一个提议(Proposal)，每个提议都有一个编号(PID)，这个编号是一直增长的，不能倒退。每个提议都需要超过半数((Senator Count)/2 +1)的议员同意才能生效。每个议员只会同意大于当前编号的提议，包括已生效的和未生效的。如果议员收到小于等于当前编号的提议，他会拒绝，并告知对方：你的提议已经有人提过了。这里的当前编号是每个议员在自己记事本上面记录的编号，他不断更新这个编号。整个议会不能保证所有议员记事本上的编号总是相同的。现在议会有一个目标：保证所有的议员对于提议都能达成一致的看法。
好，现在议会开始运作，所有议员一开始记事本上面记录的编号都是0。有一个议员发了一个提议：将电费设定为1元/度。他首先看了一下记事本，嗯，当前提议编号是0，那么我的这个提议的编号就是1，于是他给所有议员发消息：1号提议，设定电费1元/度。其他议员收到消息以后查了一下记事本，哦，当前提议编号是0，这个提议可接受，于是他记录下这个提议并回复：我接受你的1号提议，同时他在记事本上记录：当前提议编号为1。发起提议的议员收到了超过半数的回复，立即给所有人发通知：1号提议生效！收到的议员会修改他的记事本，将1好提议由记录改成正式的法令，当有人问他电费为多少时，他会查看法令并告诉对方：1元/度。
现在看冲突的解决：假设总共有三个议员S1-S3，S1和S2同时发起了一个提议:1号提议，设定电费。S1想设为1元/度, S2想设为2元/度。结果S3先收到了S1的提议，于是他做了和前面同样的操作。紧接着他又收到了S2的提议，结果他一查记事本，咦，这个提议的编号小于等于我的当前编号1，于是他拒绝了这个提议：对不起，这个提议先前提过了。于是S2的提议被拒绝，S1正式发布了提议: 1号提议生效。S2向S1或者S3打听并更新了1号法令的内容，然后他可以选择继续发起2号提议。
好，我觉得Paxos的精华就这么多内容。现在让我们来对号入座，看看在ZK Server里面Paxos是如何得以贯彻实施的。
小岛(Island)——ZK Server Cluster
议员(Senator)——ZK Server
提议(Proposal)——ZNode Change(Create/Delete/SetData…)
提议编号(PID)——Zxid(ZooKeeper Transaction Id)
正式法令——所有ZNode及其数据



# 1、ZooKeeper 简介

- Zookeeper主要服务于分布式系统，用来，统一配置管理、统一命名管理、分布式锁和集群管理
- ZooKeeper作为分布式的中间件解决了分布式系统中无法避免的对结点管理的问题（需要实时感知结点的状态、对节点进行统一管理等等）



使用Zookeeper的项目

- Kafka：主要为Kafka提供Broker和topic的注册一级多个Partiton的负载均衡等功能
- Dubbo：使用Zookeeper为期命名服务，维护各个机器的信息，维护全局的服务地址列表



**Zookeeper 的三种运行模式**

- 单机模式：开发测试环境需要
- 集群模式：Zookeeper集群通常由一组机器组成，一般是3台机器网上，每台机器都在内存中维护了当前的服务状态，并且每台机器进行通信
- 伪集群模式：集群所有的机器都在一台机器上，Zookeeper允许暴露不同的接口，则一台机器可以部署多个Zookeeper服务实例。



**Zookeeper的特点**

![img](zookeeper.assets/cc9a79e4e3d2eeb91daa131960154435.png)

1. Zookeeper的支持集群部署的，集群由一个领导者和多个跟随者组成
2. **高可用性：**集群中只要有半数以上节点存活，则Zookeeper集群就能正常服务
3. **全局一致性：**每个Service保存相同的数据副本，Client无论连接到哪个service，数据均是一致的
4. **更新请求顺序执行**：来自同一个client的更新请求按期发送顺序依次执行
5. **数据更新原子性：**更新数据要么都成功，要么都失败
6. **实时性**：Client能读取到最新的数据
7. 从设计模式的角度来说，Zk是一个观察者设计模式的框架，它负责管理和存储数据，给接收观察者的注册，数据发生变化会通知各个观察者做出反应。
8. Zookeeper保证的**CP（数据一致性）**





# 2、CAP和BASE理论

CAP定理：系统需要在系统可用性和数据一致性中做出权衡。 C：一致性   A： 可用性   P： 分区容忍性

分布式系统都是接收P的，因此主要的区别是CP（数据一致性）还是AP（可用性）。**Zookeeper保证的是CP（数据一致性）**。Eureka保证了AP（可用性）。



**BASE理论**：无法做到强一致性，分布式系统可通过自己的业务特点采取适当的方式来使得系统达到最终的一致性。分为三个部分

- **基本可用（Basically Available）**：分布式系统在出现故障的时候，允许损失部分可用性，保证核心功能的高可用。电商大促时，需要先加入购物车再下单
- **软状态（Soft State）**：允许系统存在中间状态，但最终是一致的，且中间状态不影响系统整体的可用性。分布式中存在副本，副本同步的延时则是中间态
- **最终一致性（Eventual Consistency）**：经过软状态后，最终达到一致装填，这是**弱一致性**，强一致性则不允许有中间态

平时要求系统基本可用，运行有可容忍的延迟装填，但经过一段时间后，达到最终的一致性。

**Zookeeper是让系统尽可能的高可用，而且数据能达到最终的一致性。**



# 3、一致性协议 TAB

Zookeeper为解决分布式数据一致性问题，自己定制了一致性协议 ZAB（Zookeeper Automic Broadcast）原子广播协议，能够支持崩溃恢复



## 3.1 ZAB的三个角色

Leader 领导者、Follower 跟随者、Observer 观察者。统称为zkService

- Leader：集群中唯一的写请求处理者，能够发起投票
- Follower：能够接收客户端的请求，如果是读请求则，自己处理，若是写请求，转发给Leader。选举过程中，会参与投票，有选举和被选举权
- Observer：没有选举权和被选举权的Follower

ZAB的协议，则是对该三种角色的协议，分为 **消息传播**和**崩溃恢复**



## 3.2 ZXID和myid

