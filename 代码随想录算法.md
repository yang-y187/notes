# 数组

### 二分查找

图解二分 | 最清晰易懂的讲解 | 一次性帮你解决二分边界问题【c++/java版本】

https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/

看此贴，不要看代码随想录

二分法最重要的是看[l,r]的边界问题，若该边界值，不满足条件，则不用进入下次循环中

l = m+1 或者 r = m-1。



二分法十分注意边界问题，是[left,right]还是[left,right）。这就直接影响了while循环以及对left，right的赋值

**若以[left,right]**，left = 0，right = nums.length-1,while循环要考虑二者相等的情况，所以while（left<=right）,

```java
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

**若以[left,right）**，left = 0，right = nums.length,while循环不用考虑二者相等的情况，所以while（left<right）,

在赋值时，左边界可能为目标值，右边界不是目标值

```Java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0,r = nums.length;
        while(l<r){
            int m = l+r>>1;
            //左边界可能是目标值，所以需要赋值为m+1,若赋值为m，则表示为(left,right)，与条件不符，无法准确得到初始值
            if(nums[m]<target){
                l = m+1;
            }else if(nums[m]==target){
                return m;
            }else{
                r = m;
            }
        }
        return -1;
    }
}
```



### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

11

**该模板中一定要注意，数组长度不为1，而且数组r=nums.length-1。在[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)中，r = nums.length,注意区分，为特殊情况，所以r=len，若出现嵌套循环，不清楚二分法数组长度，则r=nums.length，不能为nums.length-1。一般情况选择r=nums.length-1。==r的范围即l输出的最大范围==，若输出值可以为nums.length，则r = nums.length，否则，r=nums.length-1**

模板一：查找起始位置

```
int l = 0,r = nums.length-1;(视情况选择)
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = (l + r)>>1;
        if (nums[mid]>=target) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

模板二：查找结束位置

```
int l = 0,r = nums.length-1;

int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = ( l + r + 1 ) >>1;
        if (nums[mid]<=target) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

**区分**

模板1和模板2本质上是根据代码来区分的，而不是应用场景。如果写完之后发现是l = mid，那么在计算mid时需要加上1，否则如果写完之后发现是l = mid + 1，那么在计算mid时不能加1。

### ==[69. x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)==   ==111111==

需要计算结束位置，因为下一个值是大于target的值。使用了二分法，但是，需要注意的是：溢出情况，m*m可能超出int最大值，使用long作为计算结果。

- long temp = （long）`m*m`。
- int计算得到long值，需要将数值进行转换。==等号左右两次都要进行转换==。因为首先是两个int类型计算，在将结果转换，要是溢出此时已经溢出。



### 总结

思来想去，还是写一个总结：

上面的总结可以看一看，但我现在还是选择了代码随想录的方法。确定边界，而不是记住模板。我倾向于选择，[left,right]这种边界。在选择target的第一个出现的位置和最后一个出现的位置，添加了一个新的变量，start。每次出现nums【m】==target，先保存该m为边界，然后在【left，m-1】重新选择边界。与原来的二分法区别不大，但是有一个新的变量 start，使得性质有了很大不同。

```Java
//选择左边界
int l = 0,r = nums.length-1;
        int start = -1,end = -1;
        while(l<=r){
            int m = l+r>>1;
            if(nums[m]==target){
                start = m;
                r = m-1;
            }else if(nums[m]<target){
                l = m+1;
            }else{
                r = m-1;
            }
        }
```

**左闭右开,**

**若返回插入坐标，则返回r右边界**

```Java
l=0，r=nums.length   //[left,right）
while（l<r）{
	while(l<r){
            int m = l+r>>1;
            //左边界可能是目标值，所以需要赋值为m+1,若赋值为m，则表示为(left,right)，与条件不符，无法准确得到初始值
            if(nums[m]<target){
                l = m+1;
            }else if(nums[m]==target){
                return m;
            }else{
                r = m;
            }
        }
    return m;
}
```

**左闭右闭，**

**若返回插入坐标，则返回r+1**

```Java
 int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return r+1;
```





### 移除元素（快慢指针）

###### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/) 11

虽然我也是使用双指针，在两头操作，一个正序选择，一个倒序，若前面遇到val，后面遇到不为val，二者交换。 虽然 遍历一次，但不如这个方法思路清晰，而且方法名为快慢指针为一类题

```
class Solution {
    public int removeElement(int[] nums, int val) {
        int count = 0;
        int l=0,r=nums.length-1;
        if(r==0) return nums[0]==val? 0:1;
        while(l<=r){
            while(l<=r&&nums[l]!=val){
                l++;
            }
            while(l<=r&&nums[r]==val){
                r--;
                count++;
            }
            if(l<=r){
                int temp = nums[l]; 
                nums[l] = nums[r];
                nums[r] = temp;
            }
            
        }
        return l;
    }
}
```

==**快慢指针**==

```Java
class Solution {
    public int removeElement(int[] nums, int val) {

        // 快慢指针
        int fastIndex = 0;
        int slowIndex;
        for (slowIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;

    }
}
```

###### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

###### [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)    ==11==

，开始想不出这是快慢指针，但其实依然是快慢指针，还得好好熟悉，说到底是对快慢指针理解不深刻。

### 滑动窗口 

==滑动窗口，学的还不透，还得多做做题==



滑动窗口模型

```Java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int l = 0,res;
        for(int r=0;r<nums.length;r++){
            /**
            对比，获取最大值
            */
            while(判断是否满足条件){
                /**
                获取结果，与原结果进行对比
                另外，删除l位置的值
                */
                
                l++;
            }
        }
        return res;
    }
}
```



###### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/) ==1==

11

这也是滑动窗口，也可以**使用异位符的方式解决问题，而且速度更快一些**

**Map遍历**

- 方法一

```
for(object key:map.keySet()){
	System.out.println(map.get(key));
}
```

- 方法二

```
Set entry= map.entrySet();
Iterator iter = entry.iterator();
while(iter.hasNext()){
	Map.entry entry = (Map.entry) iter.next(); 
	System.out.println(entry.getKey());
	System.out.println(entry.getValue());
}
```

#### ==[904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)==

1

这个滑动窗口是一种特殊的方法，选择了map来构建窗口





# 链表

#### 设计链表

#### [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/) ==111==

#### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

#### 反转链表

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

本质上也是双指针

#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

两两交换链表，使用**递归**更简单

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

应该用**快慢指针**来做，会快很多。又是快慢指针，一定要掌握

#### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/) ==1==

## [148. 排序链表](https://leetcode.cn/problems/sort-list/)

# 哈希

#### [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

题目中已经说明，不会重复

#### [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

1，

本质是和求两数之和是一个意思

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)   ==111==

**11**

采用了一种双指针，并未采用hashmap,还需要注意的一点是：剪枝，在找到一个满足添加的三个数之后，后面的查找，while(l<r)的循环中需要考虑不能重复使用。

```java
l++;
while(l<r&&l>i+1&&nums[l]==nums[l-1]){
	l++;
}
```



#### [18. 四数之和](https://leetcode-cn.com/problems/4sum/)   ==11==

很重要的剪枝，

不能单纯的判断：

if(num[i]>target){

​        break;

}

因为说，可能是负数，则多负数相加会越来越小。所以，num[i]>target&&num[i]>=0 需要是大于0的才可以





**HashSet 遍历**

- ```
  for(Object key: HashSet ){
  
  ​		System.out.println(key);
  
  }
  ```

  

- ```
  Itertor iter = HashSet.itertor();
  while(iter.hasNext()){
  	System.out.println(iter.next);
  }
  ```

  

**HashMap遍历**

- ```java
  HashMap map = new HashMap();
  Set keyset = map.keySet();
  for(object key:keyset){
      System.out.println("value="+map.get(key));
  }
  ```

- ```java
  Set entryset = hash.entrySet();
  Iterator iter = entryset.iterator();
  while(iter.hasNext()){
      Map.Entry o1 = (Map.Entry)iterator.next();  System.out.println(o1.getKey()+"="+o1.getValue());
  }
  ```

# 字符串

![image-20220512160910047](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95.assets/image-20220512160910047.png)

```java 
String str2 = new String("www.runoob.com");
for (String retval: str2.split("\\.", 3)){
    System.out.println(retval);
}
```



## **KMP算法记住模型**

```Java
class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.isEmpty()) return 0;
        int n = haystack.length();
        int m = needle.length();
        String ss = " "+haystack;
        String pp = " "+needle;
        char[] s = ss.toCharArray();
        char[] p = pp.toCharArray();
        //构建next数组，数组长度为匹配串的长度（next数组是和匹配串有关的）
        int[] next = new int[m+1];
        //构造next i=0，j=0开始，i<=匹配串长度
        for(int i=2,j=0;i<=m;i++){
            //匹配不成功的话，j=next[j]
            while(j>0&&p[i]!=p[j+1])
                j = next[j];
            //匹配成功的话，先让 j++
            if(p[i]==p[j+1])
                j++;
            next[i] = j;        
        }
        //匹配过程，i=1,j=0开始，i<=原串长度
        for(int i=1,j=0;i<=n;i++){
            //匹配不成功 j=next(j)
            while(j>0&&s[i]!=p[j+1])
                j = next[j];

            if(s[i]==p[j+1])
                j++;    
            if(j==m)
                return i-m;
        }
        return -1;
    }
}
```

next[m-1]+1为最长相等字符串长度（**next数组是以统一减一的方式计算的，因此需要+1**）

#### ==[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)==

#### [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

*1*

#### [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

1

**数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。**

这句话的理解：

因为若字符串是由多个子串构成。则长度 = m*子串长度。next[i]是判定重复子串长度。是需要留出一个前缀子串，才能判定。即next[last] = (m-1)*子串长度

。又在该模板中，next[i] 本身就表示以当前字节结束的最大相等前后缀长度。    很多算法中next[i]表示前一个字节的最大相等前后缀长度或者说，当前字节的最大前后缀长度-1；



##  回文子串问题

#### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)   ==1111==

查找所以的回文字符串

```java
class Solution {
    public int countSubstrings(String s) {
        boolean[][] dp = new boolean[s.length()][s.length()];
        int count = 0;
        for(int j=0;j<s.length();j++){
            for(int i=0;i<=j;i++){
                if(s.charAt(i)==s.charAt(j)&&(j-i<2||dp[i+1][j-1])){
                    dp[i][j] = true;
                    count++;
                }
            }
        }
        return count;
    }
}
```



#### [剑指 Offer II 086. 分割回文子字符串](https://leetcode.cn/problems/M99OJA/)  ==1==

#### [剑指 Offer II 094. 最少回文分割](https://leetcode.cn/problems/omKAoA/)    ==11111==

后面的，计算最少分割次数总是理解不到位



#### [剑指 Offer II 096. 字符串交织](https://leetcode.cn/problems/IY6buf/) ==1111111==

动态规划 

# 栈

## **队列**   先进先出

LinkedList<>()

增加：
add(E e)：
addFirst(E e)：
addLast(E e)：
push(E e)：  与addFirst方法一致  

删除：
remove() ：移除链表中第一个元素;    通用方法  
remove(E e)：移除指定元素；   通用方法
removeFirst(E e)：删除头，获取元素并删除；  特有方法
removeLast(E e)：删除尾；  特有方法

pollFirst():  删除头，

pollLast():  删除尾；



查：
get(int index)：按照下标获取元素；  通用方法
getFirst()：获取第一个元素；  特有方法
getLast()：获取最后一个元素； 特有方法

peekFirst(): 获取第一个元素；

peekLast(): 获取最后一个元素；

size()  

isEmpty()



stringBuffer替换为StringBuilder append

## **StringBuilder**



增加

append() 

insert(int offset, String str)/insert(int offset, Char c)：在指定位置之前插入字符(串)



删除

delete(int startIndex,int endIndex)

deleteCharAt(int index)



改

replace(int start, int end, String str)  替换

reverse()		反转



查：

toString()

length()

charAt()



## ==[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)==

单调栈，单调栈不一定要用stack栈来做，只要是能满足单调需求即可。所以可以使用LinkedList来实现



## PriorityQueue优先级队列

默认是升序

==**升序**==

```Java
PriorityQueue<Integer> queue = new PriorityQueue<>(k,(a,b)->a-b);
```

==**降序**==

```java
PriorityQueue<Integer> minHeap = new PriorityQueue<>(k,(a,b)->b-a);
```

- - | Boolean       | `add(E e)`  将指定的元素插入到此优先级队列中。               |
    | ------------- | ------------------------------------------------------------ |
    | `void`        | `clear()`  从此优先级队列中删除所有元素。                    |
    | `boolean`     | `contains(Object o)`  如果此队列包含指定的元素，则返回 `true` 。 |
    | `Iterator<E>` | `iterator()`  返回此队列中的元素的迭代器。                   |
    | `E`           | `peek()`  检索但不删除此队列的头，如果此队列为空，则返回 `null` 。 |
    | `E`           | `poll()`  检索并删除此队列的头，如果此队列为空，则返回 `null` 。 |
    | `boolean`     | `remove(Object o)`  从该队列中删除指定元素的单个实例（如果存在）。 |
    | `int`         | `size()`  返回此集合中的元素数。                             |
    | `boolean`     | `isEmpty()`如果该队列为空，则返回true                        |
    | `<T> T[]`     | `toArray(T[] a)`  返回一个包含此队列中所有元素的数组;  返回的数组的运行时类型是指定数组的运行时类型。 |

toArray(T[] a)方法：例子 ；在括号内创建数据，new T[0]

```java
Integer[] integers = objects.toArray(new Integer[0]);
```



# 二叉树

**迭代法实现前，中，后遍历**

- 144.二叉树的前序遍历
- 94.二叉树的中序遍历
- 145.二叉树的后序遍历

```Java
//前序遍历
public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root==null) return list;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode temp = stack.pop();
            list.add(temp.val);
            if(temp.right!=null) stack.push(temp.right);
            if(temp.left!=null) stack.push(temp.left);
        }
        return list;
    }
//中序遍历
public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root==null) return list;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while(cur!=null||!stack.isEmpty()){
            if(cur!=null){
                stack.push(cur);
                cur = cur.left;
            }else{
                cur = stack.pop();
                list.add(cur.val);
                cur = cur.right;
            }
        }
        return list;
    }
//后序遍历
 public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<>();
        if(root==null) return list;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode temp = stack.pop();
            list.addFirst(temp.val);
            if(temp.left!=null)
                stack.push(temp.left);
            if(temp.right!=null)
                stack.push(temp.right);    
        }
        return list;
    }
```

**Collections.reverse(res);**   数组集合的反转

层序遍历：

```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList();
        if(root==null) return res;
        LinkedList<TreeNode> list = new LinkedList<>();
        list.add(root);
        while(!list.isEmpty()){
            LinkedList<Integer> temp = new LinkedList<>();
            int len = list.size();
            while(len-->0){
                TreeNode cur = list.poll();
                temp.add(cur.val);
                if(cur.left!=null)
                    list.add(cur.left);
                if(cur.right!=null)
                    list.add(cur.right);    
            }
            res.add(temp);
        }
        return res;
    }
```



#### [剑指 Offer II 110. 所有路径](https://leetcode.cn/problems/bP4bmD/)  ==1==

#### [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

#### **路径总和：**

https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html



==**树的递归**==

**如果需要遍历整颗树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！**

1. 递归函数的参数和返回类型

参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。

再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果**需要搜索整颗二叉树**且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
- 如果需要搜索整颗二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在[236. 二叉树的最近公共祖先 (opens new window)](https://programmercarl.com/0236.二叉树的最近公共祖先.html)中介绍）
- 如果要搜索其中**一条符合条件的路径**，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）



#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)   ==11==

**回溯算法**

在递归后，回溯时，需要删除该节点。

应用回溯，注意在结束位置，

和进入递归需要区分开，否则会像递归后，没有删除新添加的元素一样回溯的模板

（注意两点）

（1）每一次递归时需要记住已经走过的结点，不要重复走

（2）在递归后，回溯时，需要删除该节点。

```c
def backward():
    
    if (回朔点）：# 这条路走到底的条件。也是递归出口
        保存该结果
        return   
    
    else:
        for route in all_route_set :  逐步选择当前节点下的所有可能route
            
            if 剪枝条件：
                剪枝前的操作
                return   #不继续往下走了，退回上层，换个路再走
            
            else：#当前路径可能是条可行路径
            
                保存当前数据  #向下走之前要记住已经走过这个节点了。例如push当前节点
        
                self.backward() #递归发生，继续向下走一步了。
                
                回朔清理     # 该节点下的所有路径都走完了，清理堆栈，准备下一个递归。例如弹出当前节点
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)



将list<Integer>转换成int[] ,发现效率并不高，可以选择遍历

```java
int[] array = list.stream().mapToInt(Integer::intValue).toArray();
```



#### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)  ==11==

2022年1月19日

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

1

#### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) ==1==

1

2022年1月20日

#### [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

1

# 回溯算法

模板

```c
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



**标准的回溯算法**

第39题

```Java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        backTracking(candidates,target,0,new LinkedList<Integer>(),0);
        return res;
    }
    private void backTracking(int[] candidates,int target,int sum,LinkedList<Integer> temp,int index){
        if(target<=sum){
            if(target==sum) res.add(new LinkedList<Integer>(temp));
            return;
        }
        for(int i=index;i<candidates.length;i++){
            if(sum+candidates[i]>target) break;
            temp.add(candidates[i]);
            backTracking(candidates,target,sum+candidates[i],temp,i);
            temp.removeLast();
        }
    }
}
```

2022年1月21日

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

**回溯仅仅是一种方法，但是剪枝才是问题的关键。注意剪枝**

#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

注意区分树枝去重和树层去重，  树层为当前循环下        树枝是递归到后面的回溯函数中，

2022年1月23日

#### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

#### [90. 子集 II ](https://leetcode-cn.com/problems/subsets-ii/)    ==11==

注意回溯，回溯是需要有循环的，添加参数，在删除参数，没有一个遍历循环的过程回溯

2022年2月2日    （去重问题）

#### [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)     ==1111==

2022年2月6日   （去重问题，树层去重）

同一层去重时，可能数组不是有序的，则采用used[]数组或者hashSet形式来查看该层有没有使用

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

#### [332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)  ==1==

dfs与回溯的结合，拓展回溯的思路。但不以这个为重点。**还是建议官方答案**

#### [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

# 贪心算法

#### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)  ==1111==

在选择初始值时，选择了一个pre>=0   避免了不知道第一个峰值是大于还是小于的问题

#### [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

很好的体现了贪心的思想

2022年2月27日

#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

一定要注意细节

#### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/) ==1111111==

11，注意细节

只用一种方法就可以了，设置两个变量，当前步长，和下次步长。在当前步长内，获取最大的下次步长，更改一次下次步长，则次数加一。

**很多次，并不是注意细节，而是题理解的不深刻，不到位，导致总是出错**

#### [1005. K 次取反后最大化的数组和 ](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/) ==11==

#### [134. 加油站](https://leetcode-cn.com/problems/gas-station/)  ==111==

==理解贪心算法的思想，首先找局部最优，即从小处着手，==

#### [135. 分发糖果 ](https://leetcode-cn.com/problems/candy/)  ==11111==

贪心的题没有套路，就是细心，这道题就是正序遍历，倒序遍历。两个遍历一起。**这种找坑的题，可以使用正序，倒序遍历，[1,0,2]，0就是数组的坑，或者找顶峰**

```Java
class Solution {
    public int candy(int[] ratings) {
        int sum = 0;
        int[] dp = new int[ratings.length];
        Arrays.fill(dp,1);
        for(int i=1;i<ratings.length;i++){
            if(ratings[i]>ratings[i-1]){
                dp[i] = dp[i-1]+1;
            }
        }
        for(int i=ratings.length-2;i>=0;i--){
            if(ratings[i]>ratings[i+1]){
                dp[i] = Math.max(dp[i+1]+1,dp[i]);
            }
            sum+=dp[i];
        }
        return sum+dp[ratings.length-1];
    }
}
```

**正序方法**

```Java
Arrays.sort(people,(p1,p2)-> p1[1]-p2[1]);
```

或者是：

最大数值不能进行排序，可以选择 Integer.compare

```Java
Arrays.sort(points,(a,b)->Integer.compare(a[0], b[0]));
```



lamda格式的排序

**降序：**

```java
Arrays.sort(people,(p1,p2)-> p2[1]-p1[1]);
```

```
Arrays.sort(points,(a,b)->-Integer.compare(a[0], b[0]));
```



#### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

这道贪心算法的题，很明显的感觉到，贪心算法并没有固定的套路，全靠对题的理解，注意对题



不能按上面这么说，这道题与上面的糖果题类似，糖果题是1维数组，但是需要考虑左右两侧对该值的影响，所以选择，正序和倒序遍历。即先选择一边，再选择另一边。这道题是，二维数组，先选择一个维度，再考虑另一个维度，先选择，顺序，

2022年2月28日

#### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/) ==1111==

改变思路：**从查找重叠的区间并去除，改为查找完全不重叠的区间。**

这道题很难理解，主要是：

怎样判断区间的重叠，无论是以左边界还是右边界做序，首先找到最小的区间，以左边界排序，则需要从右边界开始判断是否有重叠，但右边界依然正序判断，则有误，因为左边界排序，右边界的交叉不可知，应该倒序遍历。这样，左边界最大值，右边界大于左边界，则一定是不会重叠的。区间重叠时，选择，范围最小的区间，这样才能为后面遍历留下更多的空间。

#### [738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)  ==1111==

先找局部最优，再找全局最优。以98为例

#### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

**本质使用动态规划，这仅仅是动态规划的入门级别的题，但依然不会**

# 动态规划

1. 确定dp数组（dp table）以及下标的含义
2. **确定递推公式**
3. **dp数组如何初始化**
4. **确定遍历顺序**
5. 举例推导dp数组

2022年3月1日

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)  ==1==

## 背包问题

### 01背包

（每个物品最多装一次）

==所有的题都是套这个问题==

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

![image-20220301111013052](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Img/image-20220301111013052.png)

二维数组

```Java
public static void main(String[] args) {
        int[] weight = {1,2,4};
        int[] value = {15,20,30};
        int bagsize = 4;
        testweightbagproblem1(weight,value,bagsize);
    }
    private static void testweightbagproblem(int[] weight,int[] value,int bagsize){
        int len = weight.length;
        //i,j分别表示选取前i个物品放入容量为j的背包中，dp[i][j]表示价值
        int[][] dp = new int[len][bagsize];

        for(int i=weight[0];i<bagsize;i++){
            dp[0][i] = value[0];
        }

        for(int i=1;i<len;i++){
            for(int j=0;j<bagsize;j++){
                if(j<weight[i]){
                    dp[i][j] = dp[i-1][j];
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]);
                }
            }
        }
        System.out.println(dp[len-1][bagsize-1]);
    }
```

一维数组

```Java
    public static void main(String[] args) {
        int[] weight = {1,2,4};
        int[] value = {15,20,30};
        int bagsize = 4;
        testweightbagproblem1(weight,value,bagsize);
    }
    private static void testweightbagproblem1(int[] weight,int[] value,int bagsize){
        int len = weight.length;
        //i,j分别表示选取前i个物品放入容量为j的背包中，dp[i][j]表示价值
        int[] dp = new int[bagsize+1];

        for(int i=0;i<len;i++){
            for(int j=bagsize;j>=weight[i];j--){
                dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i]);
            }
        }
        System.out.println(dp[bagsize]);
    }
```

**五个步骤都很重要，在做题的时候写下来**

1. 确定dp数组（dp table）以及下标的含义
2. **确定递推公式**
3. **dp数组如何初始化**
4. **确定遍历顺序**
5. 举例推导dp数组

**总结：**

- 01背包表示，该数值为背还是不背，背只能背一次，不能重复

- 定义dp为一维或者二维数组，现在使用一维数组

- 递推方程为dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

- dp的初始化，注意一些dp的边界问题

- 变量顺序为 两个遍历循环
  **如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！**

  ```
  for(int i=0;i<len;i++){
  	for(int j=bagsize;j>=weight[i];j--){
      	dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i]);
      }
  }            
  ```

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

可以套用例子，如果不套用例子的话，将很难解答

#### [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

与`416`很相像，其实从题中看不出来，但是这道题的本质就是将数组分为两个子集，求两个子集的最小差。即拆分为两个相等的子集。因为选择相等的子集，则相差一定最小。

- 01背包，推荐使用一维数组
- 递推方程为 dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i])，
  这道题的该方面不明显，可以认为石头的重量与价值为相同的，则求出dp[i] （背包容量为i，能够装多少重量的石头，期待是dp[i]=i，所以选择最大值）
- 初始化
  该题的初始化为0，在循环中赋值
- 由于选择了一维数组作为dp，物品的遍历放在外层，正序，背包的遍历放在内层倒序

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)    ==11111111==

01背包问题，不只是只有该容量的包能装多少的问题，这道题就是01背包中，装满该容量的背包有多少中方法

- 确定一维dp ,dp[i]表示装满容量为i的背包有多少种组合
- 递推公式为dp[j] += dp[j-nums[i]];
- 初始化，dp[0]为1
- 遍历关系不变
- 还需要考虑为负数的情况

2022年3月2日

#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

01背包的变形，将物品的重量变为了二维的m,n

### 完全背包

（不限物品个数）

==求得是，有多少种组合或者排序个数==

**如果求组合，则外层循环遍历物品，内层遍历背包容量**

```Java
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```

**如果求排列，则外层循环遍历背包容量，内层遍历物品**

```Java
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) 
            dp[j] += dp[j - coins[i]];
    }
}
```

**组合不强调元素之间的顺序，排列强调元素之间的顺序**。 

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

这道题，既不是求取容量为target的背包能装多少，也不是装满target的背包有多少中装法，**而是装满背包，用做少的次数，返回次数**

一定要注意区分：

装满背包对顺序有没有要求，这影响对循环选择

依然为五部曲

- 设置dp  表示装满容量为i的背包，所需的最少硬件数

- 设置递推公式，求取最少硬币，一定会对比求最小值。所以，又联想递推，则为dp[j = ]Math.min(dp[j],dp[j-nums[i]]+1)

- dp数组的初始化，由于选择最小值，则dp内部全部为0，会影响结果的判断，全部为最大值。可以将dp[nums[i]] = 1,dp[0]=0;将原本有的硬币设置为最小值

- 设置遍历循序，由于求最小硬币，以求组合或者顺序的方法并不影响硬币个数，所以先容量后物品，或者先物品后容量均可

#### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)   ==111==


#### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)   ==111111==

**1**

还是做错了，，出现了一些细节上的错误，主要原因是理解不到位。

，该题很特殊，为字符串，不像之前的数字加减。虽然代码随想录没这么认为，但我认为是需要顺序的，即要排序组合，因为要指定的顺序才满足要求

- 设置dp为boolean值 ,表示dp[i]为长度为i的字符串能否由字典构成
- 递推公式为dp[i] = dp[i]||(word.contains(s.substring(i-len,i))).
- 无初始化
- 所以遍历为先容量，后物品

先容量，后背包的循环

### 背包问题梳理

- dp设为1维的即可，一般问题设为一维的

- 递推公式

  - 判断容量为i的背包能否装满，或者最多装多少

    ```java
    dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i])
    ```

  - 判断装满背包有多少种方法

    ```java
    dp[j]+=dp[j-weight[i]]
    ```

  - 判断装满背包所有物品的最小个数

    ```java
    dp[j] = Math.min(dp[j],dp[j-nums[i]]+1)
    ```

- **遍历顺序（分为先遍历物品还是先遍历背包容量），相较于递推公式，更加重要**

  - 01背包
    - 先遍历物品，后遍历容量。而且内层循环为倒序遍历
  - 完全背包
    - **求组合数，不要求顺序，则是先遍历物品，后遍历背包容量 ，内层正序遍历，内层遍历从nums[i]开始**
    - **求排列数，要求顺序，则先遍历背包容量，后遍历物品	内层正序遍历，内层遍历从0开始**
  
- 完全背包，在递推时，可能会出现判断条件，以及求最小值时，需要在数组进行初始化，fill最大值，不能为默认值0；需要判断若是未初始化值，则不能进行递推



### 

三个一起做，会更好的理解

### 

## 打家劫舍问题

使用dp。对dp的形式有了变化

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

#### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)   ==111==



1，十分聪明的执行了两次dp，而且注意细节

再一次在细节方面出错

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)   ==111111==

1，第三题还是错了，需要好好做代码录上的题

还是出现了问题，这道题仅仅是记住了形式，对问题本事并没有太深的理解，所以错了很多次

上面三道题主要是，对dp长度的理解，以及形式的变化

## 买卖股票问题

dp格式为：`dp[nums.length][状态数]`，记住dp可以表示状态

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

选择一只股票，以后卖出，只卖一次。

常规的暴力算法一定超时

解法一：贪心算法

- 可左右遍历，
  先正序遍历，找最小值，倒序遍历找最大值。查找他们的最大差值即可

- 因为是找便宜的买进，再找贵的卖出。

解法二：动态规划

- 创建二维数组，dp[i][0] 不持有股票，dp[i][1] 持有股票。

**这种表示状态，挑选最佳的买入卖出问题，二维数组更加容易理解以及实现**



#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)  ==11==

当前，股票的买卖主要是为`dp[len][状态数]`，这就是有很多种状态



#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)==1111==

这道题加入了冷冻期，也是多状态情况



## 子序列子数组问题

使用dp进行递归

#### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

1

最后还是错了，大概的题解能够写出。但最终结果不对，一个细节没注意到，其实本质就是题没会，没理解到位，才出现了忘求最大值的情况

#### [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/) ==11==

1. 题目没理解到位，公共的子数组为不能截取数值，不能选择单个数值，而是选择一段长度
   区分：
   1. 子数组：为连续子序列
   2. 子序列：可以为离散的



要考虑到所有的情况，不能只是处理时间复杂度。还有处理长度等问题

而且不止有一维的方法，而且还有二维的方法

2022年3月4日

#### [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

这道题其实已经做过无数遍了，可依然开始不会做。其实有两种做法，一种是贪心，一种是动态规划，这次把动态规划的方法重新做一遍



#### [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)   ==1111==



开始以为是回溯，开始没看出来是动态规划，子序列问题，很经典的动态规划

#### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/) ==11==

开始以为是回溯，开始没看出来是动态规划，这道题很难，只能用动态规划

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)  ==111111111111111111111111111111==

老难老难了

2022年3月6日

# 单调栈

使用条件：

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。

实际上找到从先到后的递增，递减序列，可以使用单调栈。

==**单调递增栈，表示i后的所有元素都大于等于它,且单调栈中，两个元素之间[1,4] ，那1,4之间的元素大于4，且更大于1**==

[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)使用单调栈反倒是很繁琐。不如使用动态规划，正序遍历找到第i列左侧第一个的值，倒序遍历找到右侧第一个比当前列大的值

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

#### [496. 下一个更大元素 I ](https://leetcode-cn.com/problems/next-greater-element-i/)  ==111==

- 使用单调栈，注意是从栈顶到栈底是递增还是递减

2022年3月7日

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)  ==11==

#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) ==1111==

这道题还需要一个预处理的工作，在代码随想录里没有写，但也很重要。

单调栈从栈顶到栈低，为从大到小。遇到比栈顶还小的数，则计算已加入栈的最大面积。即（i-1-栈顶的下一个值）*height[栈顶]

即选择加入栈的最后两个数，作为面积的左右两边，进行计算。

这也解释了为什么要在首尾加入两个0，这样才能在计算到最后的时候，栈内可能还有数据，在取出栈内最后两个数值，进行计算。



另外，这两道题都是单调栈求面积的题，无论是单调栈内，是从大到小还是从小到大，while中，首先取得一个mid的值。接雨水的mid值代表已有方块的高度，实际能接水的高度是math.min(left，right)-mid。而在柱状图中，mid值代表要计算的高度。



#### 求能看到的楼顶个数   ==11==

![f431272ece005ba4a77d04388f81e13](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95.assets/f431272ece005ba4a77d04388f81e13-16596700089272.jpg)



很难，已经突破了找地第i个位置，左边或右边第一个大于或小于的值的问题。改成了查找第i个位置左右两侧的递增序列的个数

使用单调栈可以更方便一点，这道题，是找出第i个位置，[i+1,end]的正序递增序列的个数和[0,i-1]倒序递增序列的个数。所以需要使用单调栈

也可以采用贪心算法，时间复杂度为n*n

```java
	public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        int[] count = new int[]{50, 30, 80, 30, 27, 57};
        int[] building = findBuilding(count);
        System.out.println(Arrays.toString(building));
	}    
	public static int[] findBuilding(int[] heights) {
        // write code here
        int[] dp = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            LinkedList<Integer> list = new LinkedList<>();
            LinkedList<Integer> list1 = new LinkedList<>();
            for (int j = i-1; j >=0; j--) {
                if(list.isEmpty()||heights[j]>list.getLast()){
                    list.add(heights[j]);
                }
            }
            for (int j = i+1; j <heights.length; j++) {
                if(list1.isEmpty()||heights[j]>list1.getLast()){
                    list1.add(heights[j]);
                }
            }
            dp[i] = list.size()+list1.size()+1;
        }
        return dp;
    }
```

使用单调栈才是正解，时间复杂度O（n）;

按理说找递增序列，应该在单调栈内维护一个底层的序列，但是这样只能找到指定位置的递增序列。如果反过来，倒序维护一个递减序列，则可以得知每个位置的递增序列。

```
	public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        int[] count = new int[]{50, 30, 80, 30, 27, 57};
        int[] building = findBuilding(count);
        System.out.println(Arrays.toString(building));
    }
    public static int[] findBuilding(int[] heights) {  
        int[] dp = new int[heights.length];
        int[] right = new int[heights.length];
        int[] left = new int[heights.length];
        LinkedList<Integer> list = new LinkedList<>();
        for(int i=heights.length-1;i>=0;i--){
            right[i] = list.size();
            while(!list.isEmpty()&&heights[i]>heights[list.getLast()]){
                list.removeLast();
            }
            list.add(i);
        }
        list.clear();
        for(int i=0;i<heights.length;i++){
            left[i] = list.size();
            while(!list.isEmpty()&&heights[i]>heights[list.getLast()]){
                list.removeLast();
            }
            list.add(i);
        }
        for(int i=0;i<heights.length;i++){
            dp[i] = left[i] + right[i] + 1;
        }
        return dp;
    }
```



## 单调栈+贪心问题（要求去重最小排序）





# 排序



#### [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

归并排序

#### [剑指 Offer II 076. 数组中的第 k 大的数字 ](https://leetcode.cn/problems/xx4gT2/)      ==11==  

快排 



#### [剑指 Offer II 077. 链表排序](https://leetcode.cn/problems/7WHec2/)  

归并排序，链表也可以用归并排序



1，归并排序

将数值进行排队，先把每一个数字拆分成一个小的数组

![image-20220408083214452](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95.assets/image-20220408083214452.png)

```Java
class Solution {
    public int reversePairs(int[] nums) {
        int[] sort = new int[nums.length];
        Msort(nums,0,nums.length-1);
        return count;
    }

    private void Msort(int[] nums,int s,int e){
        if(s<e){
            int m = s+e>>1;
            Msort(nums,s,m);
            Msort(nums,m+1,e);
            Merge(nums,s,m+1,e);
        }
    }
    private void Merge(int[] nums,int s,int m,int e){
        int[] temp = new int[e-s+1];
        int left = s,mid = m,index=0;
        while(left<m&&mid<=e){
            if(nums[left]>nums[mid]){
                temp[index++]=nums[mid++];
            }else{
                temp[index++]=nums[left++];
            }
        }
        while(left<m){
            temp[index++]=nums[left++];
        }
        while(mid<=e){
            temp[index++]=nums[mid++];
        }
        for(int i=0;i<temp.length;i++){
            nums[i+s]=temp[i];
        }

    }
}
```



快速排序：

Partition（）选择一个中间值，将这个值移动到排序的位置，使得它左侧的数值都比它小，右边都比它大。并返回该坐标

==快速排序，partition一定要先遍历高部分，再遍历低的部分==

```Java
    void Qsort(int[] nums,int low,int high){
		if(s<e){   // 一定要有该判断，否则进入死循环。
        	int temp = Partition(nums,low,high);
        	Qsort(nums,low,temp-1);
        	Qsort(nums,temp+1,high);
        }
    }
    int Partition(int[] nums,int low,int high){
        
        int partivite = nums[low];
        while (low<high){
            while (low<high&&nums[high]>=partivite){   
                high--;
            }
            swap(nums,low,high);
            while(low<high&&nums[low]<=partivite){
                low++;
            }
            swap(nums,low,high);
        }
        return low;
    }
    void swap(int[] nums,int slow,int fast){
        int temp = nums[slow];
        nums[slow] = nums[fast];
        nums[fast] = temp;
    }
```

#### 

**堆排序**

https://blog.csdn.net/qq_28063811/article/details/93034625

堆排序的基本思想是：1、将带排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素；2、将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆；3、重复步骤2，如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。最后，就得到一个升序的序列了



```java
public void HeapSort(int[] arr){
        if(arr==null||arr.length==0){
            return;
        }
        int len = arr.length;
        buildMaxHeap(arr,len);
        for (int i = len-1; i >0 ; i--) {
            // 移除最大值，到末尾位置，遍历一遍后，则数组通过堆排序，实现升序
            swap(arr,0,i);
            len--;
            // 再次建立一个最大堆
            heapify(arr,0,len);
        }
    }
    // 建立一个最大堆，数组元素是  [i,len]
    private void heapify(int[] arr, int i, int len) {
        int left = 2*i+1;
        int right = 2*i+2;
        // 默认当前节点是最大值
        int maxIndex = i;
        if(left<len&&arr[left]>arr[maxIndex]){
            // 如果有左节点，并且左节点的值更大，更新最大值的索引
            maxIndex = left;
        }
        if(right<len&&arr[right]>arr[maxIndex]){
            maxIndex = right;
        }
        if(maxIndex!=i){
            // 如果最大值不是当前非叶子节点的值，那当前节点和最大值的子节点值互换
            swap(arr,i,maxIndex);
            heapify(arr,maxIndex,len);
        }
    }

    // 建立一个最大堆
    public void buildMaxHeap(int[] arr, int len) {
        for (int i = len/2-1; i >=0 ; i--) {
            heapify(arr,i,len);
        }
    }
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```



# 剑指offer

#### [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)  ==11==

#### [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)  ==1==

其实并不是马虎错，就是不懂。对题梳理的不清楚

#### [剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)  ==11==



#### [剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)  ==11==

要主要计算浮点数的值时，需要是1.0/6.0   不能是1/6；需要是浮点数计算。

另外，使用动态规划来做。这其实是很典型的动态规划，还得重复训练

​	做这道题时，感觉是动态规划，但是无从下手 。动态规划，很重要的一点就是迭代，之前迭代都是使用之前坐标下的某个值，生产新坐标，这次的迭代数组将整个数组进行替换

#### [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)   ==1==

正序遍历，倒序遍历，时间复杂度为O(n)

#### [剑指 Offer II 035. 最小时间差](https://leetcode-cn.com/problems/569nqc/)   ==11==

情况很多，注意细节。比如说比较第一个和最后一个

#### [剑指 Offer II 037. 小行星碰撞](https://leetcode-cn.com/problems/XagZNi/)

两道题都是细节错误。注意肉眼debug



# 专项训练

#### [剑指 Offer II 010. 和为 k 的子数组](https://leetcode-cn.com/problems/QTMn0o/)   ==1==

注意条件，普通的双指针是不能做的，因为数值有可能有负值，且位置不可知

#### [剑指 Offer II 011. 0 和 1 个数相同的子数组](https://leetcode-cn.com/problems/A1NYOS/)   ==1==

当看到条件为：nums.length<10^5，就知道，暴力解决问题是不现实的

#### [剑指 Offer II 014. 字符串中的变位词   ==11==](https://leetcode-cn.com/problems/MPnaiL/)

**变位题不止一道，但是变位题套路一样。首先获取不同的个数diff.建立数组进行对比。不要使用map这些。**

#### [剑指 Offer II 029. 排序的循环链表   ==11==](https://leetcode-cn.com/problems/4ueAj6/)



#### [698. 划分为k个相等的子集   ==111==](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/) 

#### [剑指 Offer II 050. 向下的路径节点之和](https://leetcode.cn/problems/6eUYwP/)   ==1==

#### [剑指 Offer II 051. 节点之和最大的路径   ==11==](https://leetcode.cn/problems/jC7MId/)



#### [剑指 Offer II 057. 值和下标之差都在给定的范围内   ==111==](https://leetcode.cn/problems/7WqeDu/)

TreeSet

有序，唯一数组。可以正序，倒序。

- **ceiling(element)** - 返回大于指定元素(element)的那些元素中的最小元素。若没有，则返回null。所以返回类型为包装类
- **floor(element)** - 返回小于指定元素(element)的元素中最大的元素。若没有，则返回null。所以返回类型为包装类
- **使用时，首先判断是够为null，不为null再操作**
- ```
              Long temp = set.ceiling((long)nums[i]-t);
              if(temp!=null&&temp<=(long)nums[i]+t){
  ```




方法：

- `pollFirst()` 
- `pollLast()` 
- `remove(Object o)` 
- First()
- Last()



#### [剑指 Offer II 058. 日程表](https://leetcode.cn/problems/fi9suh/)   ==1==

TreeMap，按key来排序

注意两个方法：注意表明`Map.Entry<Integer,Integer>`不能减少`Map.`这个信息

```Java

Map.Entry<Integer,Integer> ceil = map.ceilingEntry(start);   //大于等于key，或者null
Map.Entry<Integer,Integer> floor = map.floorEntry(start);   // 小于等于key，或者null
```

- map.firstKey()
- map.firstEntry()
- map.pollFirstEntry()
- map.lastKey()
- map.lastEntry()
- map.pollLastEntry()

#### [剑指 Offer II 061. 和最小的 k 个数对   ==1==](https://leetcode.cn/problems/qn8gGX/)

这几道题都是排序集合的应用，可以看出，PriorityQueue和TreeMap和TreeSet都有用







#### [剑指 Offer II 063. 替换单词](https://leetcode.cn/problems/UhWRSj/)        ==1==

**使用前缀树，前缀树更多的是一种工具。判断是否由某个字符串起始。**剑指offer有一类题都使用前缀树，主要是看字符串是否匹配。



#### [剑指 Offer II 067. 最大的异或](https://leetcode.cn/problems/ms70jA/)  ==1==

#### [剑指 Offer II 070. 排序数组中只出现一次的数字](https://leetcode.cn/problems/skFtm2/)   ==1==



#### [剑指 Offer II 073. 狒狒吃香蕉](https://leetcode.cn/problems/nZZqjQ/)  ==11==



#### [剑指 Offer II 093. 最长斐波那契数列](https://leetcode.cn/problems/Q91FMA/)   ==1==

双指针的变形，立马就不会做了。与求三个数之和相仿。



#### [剑指 Offer II 097. 子序列的数目](https://leetcode.cn/problems/21dk04/)   ==11==

动态规划，一看到这种题总想到回溯，其实动态规划是更快一点

剑指 Offer II 106. 二分图



剑指 Offer II 107. 矩阵中的距离  ==111==

剑指 Offer II 108. 单词演变 ==1111==

剑指 Offer II 110. 所有路径 ==1==



## 并查集





# 杂题

#### [29. 两数相除](https://leetcode.cn/problems/divide-two-integers/)



#### [227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)   ==1==

  

#### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

#### [151. 颠倒字符串中的单词 ](https://leetcode.cn/problems/reverse-words-in-a-string/) ==1==

#### [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)



#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)  ==111111111111111111111111111111==



#### [336. 回文对](https://leetcode.cn/problems/palindrome-pairs/)

困难题，很难

#### [670. 最大交换](https://leetcode.cn/problems/maximum-swap/)   ==11==

#### [581. 最短无序连续子数组 ](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)  ==11==



#### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)  ==11==



#### [153. 寻找旋转排序数组中的最小值 ](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)  ==11==

#### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)  ==11==



#### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)  ==1==

![image-20220917223032648](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95.assets/image-20220917223032648.png)
