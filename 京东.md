# java 优雅

## 用流更优雅

```java
for (Message message : messageList) {
		......                        
}
```

改为

```
messageList.forEach(message ->
		......     
);
```

==**stream的filter是过滤掉为false的对象**==

## 集合null和empty()判断

```Java
CollectionUtils.isNotEmpty(messageList) // 既判断null，也判断empty（）
Objects.nonNull() & Objects.isNull() // 判断null
StringUtils 。。。 // 大同小异，用jd的包
  
```

## Collectors.emptyList() 慎用

Collectoers.emptyList()创建的集合无法add和remove对象

原因：

创建的对象虽然是ArrayList，但与我们理解的ArrayList是两个类，虽然都继承了AbstractList，但是该类没有重写add和remove方法，而abstractList类的add和 remove方法是勾子方法，即直接抛出异常，使得继承类必须重写该方法。

**Arrays.asList()同理**



Collections.emptyList(); 内部

```java
public static final <T> List<T> emptyList() {
        return (List<T>) EMPTY_LIST;
    }

    /**
     * @serial include
     */
    private static class EmptyList<E>
        extends AbstractList<E>
        implements RandomAccess, Serializable {
        private static final long serialVersionUID = 8842843931221139166L;

        public Iterator<E> iterator() {
            return emptyIterator();
        }
        public ListIterator<E> listIterator() {
            return emptyListIterator();
        }

        public int size() {return 0;}
        public boolean isEmpty() {return true;}

        public boolean contains(Object obj) {return false;}
        public boolean containsAll(Collection<?> c) { return c.isEmpty(); }

        public Object[] toArray() { return new Object[0]; }

        public <T> T[] toArray(T[] a) {
            if (a.length > 0)
                a[0] = null;
            return a;
        }

        public E get(int index) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }

        public boolean equals(Object o) {
            return (o instanceof List) && ((List<?>)o).isEmpty();
        }

        public int hashCode() { return 1; }

        @Override
        public boolean removeIf(Predicate<? super E> filter) {
            Objects.requireNonNull(filter);
            return false;
        }
        @Override
        public void replaceAll(UnaryOperator<E> operator) {
            Objects.requireNonNull(operator);
        }
        @Override
        public void sort(Comparator<? super E> c) {
        }

        // Override default methods in Collection
        @Override
        public void forEach(Consumer<? super E> action) {
            Objects.requireNonNull(action);
        }

        @Override
        public Spliterator<E> spliterator() { return Spliterators.emptySpliterator(); }

        // Preserves singleton property
        private Object readResolve() {
            return EMPTY_LIST;
        }
    }
```

AbstractList内部

```java
public E set(int index, E element) {
    throw new UnsupportedOperationException();
}

/**
 * {@inheritDoc}
 *
 * <p>This implementation always throws an
 * {@code UnsupportedOperationException}.
 *
 * @throws UnsupportedOperationException {@inheritDoc}
 * @throws ClassCastException            {@inheritDoc}
 * @throws NullPointerException          {@inheritDoc}
 * @throws IllegalArgumentException      {@inheritDoc}
 * @throws IndexOutOfBoundsException     {@inheritDoc}
 */
public void add(int index, E element) {
    throw new UnsupportedOperationException();
}

/**
 * {@inheritDoc}
 *
 * <p>This implementation always throws an
 * {@code UnsupportedOperationException}.
 *
 * @throws UnsupportedOperationException {@inheritDoc}
 * @throws IndexOutOfBoundsException     {@inheritDoc}
 */
public E remove(int index) {
    throw new UnsupportedOperationException();
}
```



## 构造器

@NoArgsConstructor 无构造器注解

@AllArgsConstructor 全构造器注解

## Try-catch异常打印

**不要使用e.printStackTrace()**,只是打印到控制台，并且过多占用内存空间

建议使用以下方式

```java
try{
  xxxx
}catch (Exception e) {
	log.error("xxx错误，阿巴阿巴xxx", e.getMessage());
	/*也可以e.getCause().getMessage()
	在getMessage()获取异常名称的基础上，
	添加了异常原因
	e.getMessage()是将错误打印至error.log日志文件中
	*/
}
```

## Optional

工具类，与stream功能类似，主要应用于object对象，而非集合

**Optional.ofNullable**(T value) ：传入参数，若为null，则返回Optional.empty()

- 内部相关方法

  - **ifPresent**：如果存在，则执行内部方法。

    - ```java
      Optional.ofNullable(getUserById(id)).ifPresent(()->{xxxxx});
      ```

    ```java
    Optional<User> user = Optional.ofNullable(getUserById(id));
    user.ifPresent(u -> System.out.println("Username is: " + u.getUsername()));
    ```

  - **orElse**: 如果optional没有值，返回orElse 方法传入的参数

    - ```java
      User user = Optional
              .ofNullable(getUserById(id))
              .orElse(new User(0, "Unknown"));
      ```

  - **orElseGet**：与orElse()区别，可以穿入参数

  - **orElseThrow**：在方法内部抛出异常

  - **map**：可以多次map，与stream类似，输出值

  - **filter**：过滤，==为true时通过，false滤除==

  - 例子：

    ```java
    Optional<String> username = Optional
            .ofNullable(getUserById(id))
            .filter(user -> user.getId() < 10)
            .map(user -> user.getUsername());
    ```

凡是涉及到字符转换的，建议使用optional进行转换，尤其，空null传入报异常的情况，建议采用以下方法规避

```java
Optional.ofNullable(info.getFirstLevelName()).orElse(null);
```

## JSON转换

  常用的JSON转换，需要判断str=null和**str=“”**（很容易被忽略，因此选择stringutils.isEmpty()判断）的情况

```java
JSON.parseObject(str);
```

因此，写法改为：

```java
JSON.parseObject(Optional.ofNullable(str)
                    .filter(StringUtils::isNotEmpty).orElse("{}")
            );
```



## var和val 区别

伪关键字，存在的原因是：减少编写java代码相关的模式，并且保证它的安全，允许省略不必要的声明

- **var**- 用于可变的局部变量
- **val**--用于最终的（不可变的）局部变量








## 断言

阿里规范中，强制单元测试中，不能使用sout手动比对，而是使用断言。

，满足条件才能继续运行，若不满足条件，则出现异常

Assert.assertEquals

Assert.assertTrue

## 反序列化

`List<DTO>`的反序列化，只要指定泛型内的泛型。

```java
// 普通对象DTO对象的反序列化
JSON.parse(string, DTO.class);
// 有泛型集合的反序列化,List<DTO> 需要指定泛型。两种方法均可
JSON.parseArray(stringm,DTO.class);
JSON.parse(string,new TypeReference< List<DTO>{});
```

## 可读性优于性能优化

在使用一个类对象时`a（b（c））`，如该关系表示下，若需要更改属性c，那么此时需要创建一个新的b对象，并把c的值赋进去，而不是直接get，set进行赋值，此时虽然创建新对象会有性能损耗，但是这点时间可忽略不计，但若直接赋值，可能因为地址引用，其他地方的属性也是b属性，那么此处的内容随着a内容的修改一起更改。另外这样更便于阅读。可读性更重要，如果性能更重要的话，那么我们完全可以采用c++进行开发，选择性能更好的机器运行。此话的含义不是性能不重要，而是在遍历一遍和遍历两遍的选择时，优先可读性高的方式。

## 为什么有些代码写变量是private static final

private：本类使用，不能被继承子类调用

final：不能被改变继承

static：类加载时创建该对象

三者一起出现，则该类对象，无论创建多少个，但该private static final 修饰的对象只需要创建一个。典型例子：Logger 。节省空间，并且不必因为多个实例而创建多个对象，节省空间。



## BeanUtils.copyProperties

该方法可以将两个不同的对象进行赋值。

```
Vo vo = new Vo();
// 得到 PO
BeanUtils。copyProperties(PO,vo);
// 此刻，vo拥有PO的所有属性名称相同的属性，不相同的属性，则需要手动处理。
```

该方法不建议使用，虽然可以copy相同名称的属性，其内部通过反射进行赋值，虽然方便，但是性能低下，花费时间远高于手动get，set的时间



## Map初始化赋值方式

1. 使用代码块，添bu添加static都可

   ```java
   private static final Map<String, String> myMap = new HashMap<String, String>();
       static {
           myMap.put("张三", "北京");
           myMap.put("李四", "上海");
       }
   ```

2. 双括号初始化（匿名内部类的方式）

   ```java
   HashMap<String, String> myMap = new HashMap<String, String>() {{
           put("张三", "北京");
           put("李四", "上海");
       }};
   ```

3. java 9 高版本（可我用的java 8）

   ```java
   // 最多存储10个元素
   Map<String, String> test1 = Map.of(
       "a", "b",
       "c", "d"
   );
    
   // 没有限制
   Map<String, String> test2 = Map.ofEntries(
       entry("a", "b"),
       entry("c", "d")
   );
   ```

4. 流的方式，目前觉得最优雅的方式

   ```java
   private Map<String, String> map = Stream.of(
                       new MutablePair<>("1", "1"),
                       new MutablePair<>("2", "2"),
                       new MutablePair<>("3", "3"),
                       new MutablePair<>("4", "4"),
                       new MutablePair<>("5", "5")
               )
               .collect(Collectors.toMap(MutablePair::getLeft, MutablePair::getRight));
   ```

   

==不要使用双花括号，匿名内部类的方式，否则会内存溢出==



## StringUtils.hasText()

判断是否有文字，为空或者空格则是false：`null`     `""`          ` "   "`,都为false，否则为true



## @Builder

@Builder注解是lombok的注解，通过创建者方式创建对象使代码更加优雅。

```java
User wyy = User.builder().name("wyy").age(18).build();
```

确实更加优雅，但是有几个**容易踩坑的点**



- Builder创建的对象会忽略默认值   （）

![image-20231012103333295](京东.assets/image-20231012103333295.png)

- Builder注解 会默认生成一个全参的构造器，而没有无参数的构造器。若是有继承子类，则该子类需要调用该构造器，需要传这两个参数才可

![image-20231012103512289](京东.assets/image-20231012103512289.png)

![image-20231012104015297](京东.assets/image-20231012104015297.png)



## ArrayList removeIf() 方法

arraylist.removeIf(Predicate<E> filter) 删除所有符合条件的元素。返回true: 删除



# 泛型

即，若需要传入参数为泛型，则方法修饰词上需要有  `<T>`表示所有类型

```
    /**
     * 这个<T> T 可以传入任何类型的List
     * 关于参数T
     * 第一个 表示是泛型
     * 第二个 表示返回的是T类型的数据
     * 第三个 限制参数类型为T
     *
     * @param data
     * @return
     */
    private <T> T getListFisrt(List<T> data) {
        if (CollectionUtils.isEmpty(data)) {
            return null;
        }
        return data.get(0);
    }
```

流 注意事项



# 多线程

## 异步编排

### CountDownLatch

**CountDownLatch是一个工具类，用来协调多个线程间的同步。CountDownLatch能等待其他的一些线程完成工作后，再执行相应的代码。通过一个计数器完成。**计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成一些任务，然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。

**CountDownLatch的用法**

- 用法一：某个线程在开始运行前等待n个线程执行完毕，首先创建初始化new CountDownLatch(n),每个任务执行完毕后，将计数器减一，countdownLatch.countDown()。当计数器的值变为0后，在Count DownLatch上await()的线程就被唤醒。
  - 用于等待多个任务执行结束后，再继续执行。（任务数不固定，无法使用CompletableFuture异步编排）
- 用法二：做法初始化一个共享的CountDownLatch(1),将其计算器值设为1，多个线程在开始任务前首先countdownlatch.await()，当主线程调用countDown()时，计数器变为0，多个线程同时被唤醒。
  - 用于要求多个线程同时并行执行

**CountDownLatch的不足**

CountDownLatch是一次性的，计算器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。



### **CompletableFuture**

==**为什么使用异步编排？**==

- 将两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。此时需要异步编排。（若是结果不相互依赖，直接异步即可，没必要异步编排）
- 查询商品详情页的逻辑复杂，有些数据需要远程调用。必然花费更多时间。可以使用线程池，异步获取数据，进行编排提高响应速度。
- 例如：进入商品详情页（携带skuId）
  1. 获取SKu的基本信息    异步1
  2. 获取SKU的图片信息    异步1
  3. 获取SKU的促销信息     异步1
  4. 获取spu的所有销售属性   需要等待查询到（获取SKu的基本信息中的spuId）才能获取spuId     异步2
  5. 获取规格参数  异步2
  6. 获取spu详情    异步2
- 原本需要等待6个请求时间累加，变为两次异步操作的时间，极大的提高了响应时间。





jdk1.8，添加了CompletableFuture，进行异步编排。

将两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。此时需要异步编排。

- ### 创建异步对象

  - 没返回值runAsync

    ```Java
            ExecutorService executor = newFixedThreadPool(10);
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                System.out.println(Thread.currentThread().getId());
            }, executor);
    ```

  - 有返回值supplyAsync

    ```Java
    CompletableFuture<Long> future = CompletableFuture.supplyAsync(() -> {
                long id = Thread.currentThread().getId();
                System.out.println(id);
                return id;
            }, executor);
            Long aLong = future.get();
    ```

- ### 线程执行完成的回调方法

  - whenComplete(BiConsumer<? super T,? super Throwable> action);
    - 在线程执行完成后，将返回值和异常，进行操作，T为线程执行结果，action为异常信息。
  - exceptionally(Function<Throwable,? extends T> fn);
    - 线程出现异常，优先进入该方法，可以设置返回值，使得即使异常也会有返回值
  - whenComplete与exceptionally一块执行，若出现异常，先执行exceptionally，再执行whenComplete

whenComplete 和 whenCompleteAsync 的区别：
		whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。
		whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。

- ###  线程串行化方法

  ​	（即一个线程执行结束，再执行下一个线程）

  - thenRun，thenRunAsync方法：上一个线程结束，执行thenRun，不能获取上一个线程的结果，也不能有返回值
  - thenAccept，thenAcceptAsync：能获取上一个线程的结果进行操作，但不能有返回值
  - thenApply，thenApplyAsync：能获取上一个任务的结果，并返回当前值

```Java
        ExecutorService executor = newFixedThreadPool(10);
        CompletableFuture<Long> future = CompletableFuture.supplyAsync(() -> {
            long id = Thread.currentThread().getId();
            System.out.println(id);
            return id;
        }, executor).thenApplyAsync(res->{
            return res*2;
        },executor);
        Long aLong = future.get();
        System.out.println(aLong);
```

- ### 多任务组合

  - allOf：等待所有任务完成

  - anyOf：只要有一个任务完成。返回值调用anyof方法，可以获取率先执行结束线程的结果

    ```Java
    public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs);
    
    public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs);
    ```

  - 注意：这两个方法调用，要使用get();,否则在anyof中不能，达到any的目的


    ```Java
            CompletableFuture<Void> all = CompletableFuture.allOf(future1, future2, future3);
            all.get();
    ```

# MySql

## 批量将分组后数据排序，然后取第一条数据

```sql
select * from (select distinct(a.id) tid, a.* from template_detail a
               where a.template_id in (3, 4)
              order by a.id desc) tt
group by tt.template_id;
```

步骤：先进行排序（排序时where过滤），再进行分组，会自动获取分组后的第一条数据

- **==distinct(a.id)==**为什么是distinct呢？
  - 为了避免合并中使用derived_merge。（合并的构造）

derived_merge：指的是一种查询优化技术，作用就是把派生表合并到外部的查询中，提高数据检索的效率。这个特性在MySQL5.7版本中被引入。

虽然看着吊但是不好用且容易出错。

子查询调用下面操作可以关闭该优化操作：

```sql
可以通过在子查询中使用任何阻止合并的构造来禁用合并，尽管这些构造对实现的影响并不明确。 防止合并的构造对于派生表和视图引用是相同的：
   1.聚合函数（ SUM() ， MIN() ， MAX() ， COUNT()等）
   2.DISTINCT
   3.GROUP BY
   4.HAVING
   5.LIMIT
   6.UNION或UNION ALL
   7.选择列表中的子查询
   8.分配给用户变量
   9.仅引用文字值（在这种情况下，没有基础表）

```

如果没有distinct，子查询中的order by失效。加上distinct则结果正确。临时表中使用order by，为使其生效，则需要满足三个条件

- 外部查询禁止分组或者聚合
- 外部查询未指定`having，HAVING， order by`
- 外部查询将派生表或者视图作为`from`句中唯一指定源

不满足全部条件，则order by会被忽略。原因在于derived_merge优化后不会执行filesort操作，所有order by失效。所以添加distinct。



## 事务问题

看业务场景，涉及多张表的数据，必须开启事务。

我们目前toB业务场景下，不开启事务，节省性能。只有在同时写入多张表时才开启事务。

原因：

请求数据库连接的时间长，数据库连接资源宝贵

若请求运行的时间长，操作的数据比较多。 锁定太多的数据，造成了大量的阻塞和锁超时，回滚时需要的时间较长，执行时间长，容易造成主从延迟。

**大事务**：一般指运行时间长，操作的数据比较多的事务

查询执行时间超过10s的事务

```SQL
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>10
```

### 事务执行时间长的影响

- 锁定数据过多，容易造成大量的死锁和锁超时

  系统中不同的事务之间出现循环资源依赖，涉及的事务在等待别的事务释放资源时，就会导致这几个事务较长时间等待
  ![img](京东.assets/6ce5wx9k12.jpeg)

  id =1 和id = 2的行锁分别被A事务和B事务占用，且互相等待对方释放资源，则进行死锁。

  - 死锁处理策略：
    - 等待死锁超时：超时时间默认为50s
    - 死锁检测：默认开启死锁检测，死锁检测是当事务被锁时，检测它所依赖的线程有没有被锁住，直到最后判断是否死锁

- 回滚记录占用大量存储空间，事务回滚时间长
  - 多版本并发控制，mvcc需要占用较大存储空间，恢复数据需要读取mvcc中的数据进行回滚
- 执行时间长，容易造成主从延迟
  - 主库上等事务执行完成后才会写入binlog，再主从复制到从库。所以事务未执行结束，从库无法直接得到数据

### 如何解决大事务带来的问题

- **两阶段协议（见MySQL内容）
  - ![image-20230718205400236](京东.assets/image-20230718205400236.png)
  - 两阶段提交时，先更新数据，再写入redo log日志保证数据的一致性。若事务发生异常，则可以通过redo log日志进行回滚。
  - 行锁是事务执行结束后才释放的。因此，若事务中需要锁定多行，可能造成锁冲突，最可能影响并发度的锁尽量最后统一处理。
    【例】顾客在影院买票。
    1. 扣顾客的票钱
    2. 加影院的余额
    3. 生成一条记录日志
       可能存在多个顾客购买电影票，若过早锁定影院余额，那么锁等待时间过长。因此最后的顺序是 3 1 2 .将可能存在锁冲突的操作尽量放在最后操作

- 基于死锁检测
  - 死锁检测会检测当前时刻请求的所有线程，时间复杂度为O(n)。减少n的数量。n=同一行数据的并发数，并发数小则检测成本低
  - 可以参考concurrentHashMap中的分段锁设计，将影院余额账户，由原来的一条记录，改为10条记录。账户余额等于10条记录的总和。此时冲突可能会小很多
- 基于事务的隔离级别
  - MySQL的数据隔离级别是可重复读。在当前隔离级别下，
    - 若有索引时，以索引列更新数据，则会有间隙锁，行锁，临键锁，从而锁定一些行
    - 若没有索引，则更新数据会使用表锁
  - 隔离级别改为读已提交，则写数据会锁定一行。

# Spring：

## @Qualifier 注解

根据名称进行注入，避免了通过类注入时，有多个同一类。下面代码会报错。

```
 @Component("fooFormatter")
    public class FooFormatter implements Formatter {
        public String format() {
            return "foo";
        }
    }

    @Component("barFormatter")
    public class BarFormatter implements Formatter {
        public String format() {
            return "bar";
        }
    }

    @Component
    public class FooService {
        @Autowired
        private Formatter formatter;
        
        //todo 
    }
```

需要该操作

```
 @Component
     @Qualifier("fooFormatter")
     public class FooFormatter implements Formatter {
         public String format() {
             return "foo";
         }
     }
 
     @Component
     @Qualifier("barFormatter")
     public class BarFormatter implements Formatter {
         public String format() {
             return "bar";
         }
     }

    @Component
    public class FooService {
        @Autowired
        @Qualifier("fooFormatter")
        private Formatter formatter;
        
        //todo 
    }
```

## @Bean注解

@Bean 注解方法时，参数 是通过 @Autowrited 注解方式，进行自动注入的

```java
	@Bean
	public MyBeanTest MyBeanTest(@Qualifier(value="mytest") Mybean mytest){
		return MyBeanTest (mytest);
	}
```



## 读取配置文件值

yml配置文件

```
api:
  mes:
    MES_SOCKET: http://192.168.99.140:8081
```

### 方法一

方法一优雅

```
@Component
@ConfigurationProperties(prefix = "api.mes")
public class MesApiConfig {

    /**
     * 读取yml下配置好的api-mes——socket
     */
    private String MES_SOCKET;
   
}
```

方法二

```
@Component
public class MesApiConfig {

    /**
     * 读取yml下配置好的mes——socket
     */
    @Value("${api.mes.MES_SOCKET}")
    private String MES_SOCKET;

}
```

## @primary注解

当IOC容器中，有同一类型的多个实现，可以指定名称进行注入。@Autoware @Qualifier(“beanName”)，或者是@resource("beanName")

@Primary和@Bean一起使用，再获取该类型的对象时，优先注入有@primart注解的类。

## springboot Test 测试类中排除一个bean类自动注入

添加注解：**@EnableAutoConfiguration(exclude=SecurityAutoConfiguration.class)**



## ApplicationListener接口和ContextRefreshedEvent事件

一般ApplicationListener接口和ContextRefreshedEvent事件结合在一起使用

```java
public class xxxx implements ApplicationListener<ContextRefreshedEvent>{
  @Override
    @SneakyThrows
    public void onApplicationEvent(ContextRefreshedEvent event) {
        
    }
}
```

ApplicationListener接口，旨在监听传入的泛型事件，在事件发布后，会触发该实现类的onApplicationEvent方法.

在IOC容器启动过程时，**IOC容器初始化完成后**，会发布一个ContextRefreshedEvent事件，此时，所有该事件的监听者，会自行执行方法。

**使用场景**

在IOC容器启动完成后，才可配置的的场景下，可以使用该方法 。

例：mq生产者配置类，配置完成后，获取的producer是不可用的，需要producer.start() 方法才能行，可放在onApplicationEvent方法中。

## InitializingBean接口

spring IOC容器启动过程中，**在实例化该Bean后，需要执行初始化方法，此时会执行InitializingBean 接口下的afterPropertiesSet方法**，若没有实现该接口，则执行默认的initMethod方法

:warning:执行初始化方法，是实例完，**并注入完所有属性后**，才执行该初始化方法。



在spring 加载 bean 的源码类 AbstractAutowiredCapableBeanFactory 

```java
protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)
        throws Throwable {
        // 判断 bean 是否实现了 InitializingBean 接口
    boolean isInitializingBean = (bean instanceof InitializingBean);
    if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
        if (logger.isTraceEnabled()) {
            logger.trace("Invoking afterPropertiesSet() on bean with name '" + beanName + "'");
        }
        // 系统安全处理器为空则直接执行 else 流程, 调用 afterPropertiesSet 方法
        // 默认为空，所以直接 else 流程
        if (System.getSecurityManager() != null) {
            try {
                AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {
                    ((InitializingBean) bean).afterPropertiesSet();
                    return null;
                }, getAccessControlContext());
            }
            catch (PrivilegedActionException pae) {
                throw pae.getException();
            }
        }
        else {
            // 直接调用 afterPropertiesSet
            ((InitializingBean) bean).afterPropertiesSet();
        }
    }

    if (mbd != null && bean.getClass() != NullBean.class) {
        // 判断是否指定了 initMethod 方法, 如果指定会进行调用
        String initMethodName = mbd.getInitMethodName();
        // 如果 initMethod 方法名称为 “afterPropertiesSet”, 则不进行调用
        if (StringUtils.hasLength(initMethodName) &&
                !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
                !mbd.isExternallyManagedInitMethod(initMethodName)) {
            // 通过反射调用 initMethod 指定方法
            invokeCustomInitMethod(beanName, bean, mbd);
        }
    }
}
```

## 单表操作不必开启事务

只对单张表进行操作不必开启事务，因为SQL异常或者执行业务计算异常都会抛出，阻断执行。另外开启事务影响性能。



## Mybatis-TypeHandler



## TriFunction

```java
@FunctionalInterface
public interface TriFunction<A, B, C, R> {
    R apply(A var1, B var2, C var3);
}
```

可以将一个方法作为参数传入

```java
        TriFunction<String, Integer, String, Person> triFunction = Person::new;
        Person p4 = triFunction.apply("laodu", 35, "男");
```

与之相似的，还有两个参数作为入参的BiFunction

## @Import注解和@Bean注解

Import注解注入时，名称是全类名

Bean注解注入时，名称是方法名。

`@Import({Student.class})`把`Student`类注入到了Spring容器中，beanName默认为全限定类名`com.shepherd.common.config.Student`，而`@Bean`注入的默认为**方法名**，这也是两者的区别。



# 日志系统

以常用的Slf4J举例子，日志系统是门面模式的典型实现。

这种辅助系统，不得参与到业务的具体实现，解耦合，可插拔的。

门面模式：**外部与一个子系统的通信必须通过一个统一的外观对象使得子系统更易用**

![img](京东.assets/801753-20180321204740208-1670144043.png)

门面系统的核心即Facade门面对象，实现的核心点

- 清晰所有子角色的功能
- 将客户端发来的请求分派到子系统，不进行实际的业务处理
- 不参与到子系统内部的业务逻辑中

**slf4j是一个日志标准，而不是日志系统的具体实现。即只有slf4j无法打印日志**

slf4j

- 提供了日志接口
- 提供了获取日志的方法

我们系统使用了logback日志系统，若引用的jar包A，使用log4j日志系统，在我们系统运行时，需要支持和维护至少两个日志系统框架，十分不便。因此，在日志系统上层加入一个适配层，由适配层选择日志系统，调用方只关注打印日志，不必关注如何打印。

并非所有的日志系统都是slf4j的具体实现。slf4j-simple，logback是，但log4j不是，此时需要一个专门的桥接slf4j-log4j12实现。因为日志标准化接口，除了slf4j，还有commons-logging等。

注意：若系统中引入多个日志系统，一条日志不会多个日志系统都打印执行，而是选择其中一个实现slf4j的实现进行打印。

具体实现：

我们通常使用@Slf4j注解，该注解在编译时，会成为

```java
private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);
```

lombok的功劳，与@Data,@Get,@Set注解类似。

首先在代码获取log日志对象

```java
Logger logger = LoggerFactory.getLogger(Object.class);
```

获取方法内部

```Java
    public static Logger getLogger(Class<?> clazz) {
        Logger logger = getLogger(clazz.getName());
        if (DETECT_LOGGER_NAME_MISMATCH) {
            Class<?> autoComputedCallingClass = Util.getCallingClass();
            if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) {
                Util.report(String.format("Detected logger name mismatch. Given name: \"%s\"; computed name: \"%s\".", logger.getName(), autoComputedCallingClass.getName()));
                Util.report("See http://www.slf4j.org/codes.html#loggerNameMismatch for an explanation");
            }
        }

        return logger;
    }
    public static Logger getLogger(String name) {
        ILoggerFactory iLoggerFactory = getILoggerFactory();
        return iLoggerFactory.getLogger(name);
    }
```

其中的getLogger(clazz.getName())方法中首先获取log日志工厂，再通过工厂获取日志系统对象的具体实现。



```java
// 初始对象为0，保证线程安全
static volatile int INITIALIZATION_STATE = 0;
public static ILoggerFactory getILoggerFactory() {
        if (INITIALIZATION_STATE == 0) {
            Class var0 = LoggerFactory.class;
            synchronized(LoggerFactory.class) {
                if (INITIALIZATION_STATE == 0) {
                    INITIALIZATION_STATE = 1;
                    performInitialization();
                }
            }
        }

        switch(INITIALIZATION_STATE) {
        case 1:
            return SUBST_FACTORY;
        case 2:
            throw new IllegalStateException("org.slf4j.LoggerFactory in failed state. Original exception was thrown EARLIER. See also http://www.slf4j.org/codes.html#unsuccessfulInit");
        case 3:
            return StaticLoggerBinder.getSingleton().getLoggerFactory();
        case 4:
            return NOP_FALLBACK_FACTORY;
        default:
            throw new IllegalStateException("Unreachable code");
        }
    }
```

执行初始化方法，重点在bind方法，

```java
private static final void performInitialization() {
        bind();
        if (INITIALIZATION_STATE == 3) {
            versionSanityCheck();
        }

    }

   private static final void bind() {
        try {
            String msg;
            try {
                Set<URL> staticLoggerBinderPathSet = null;
                if (!isAndroid()) {
                  // 寻找可能的log系统绑定路径集合
                    staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();
                    reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);
                }

                StaticLoggerBinder.getSingleton();
                INITIALIZATION_STATE = 3;
                reportActualBinding(staticLoggerBinderPathSet);
            } catch (NoClassDefFoundError var7) {
                msg = var7.getMessage();
                if (!messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) {
                    failedBinding(var7);
                    throw var7;
                }

                INITIALIZATION_STATE = 4;
                Util.report("Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".");
                Util.report("Defaulting to no-operation (NOP) logger implementation");
                Util.report("See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.");
            } catch (NoSuchMethodError var8) {
                msg = var8.getMessage();
                if (msg != null && msg.contains("org.slf4j.impl.StaticLoggerBinder.getSingleton()")) {
                    INITIALIZATION_STATE = 2;
                    Util.report("slf4j-api 1.6.x (or later) is incompatible with this binding.");
                    Util.report("Your binding is version 1.5.5 or earlier.");
                    Util.report("Upgrade your binding to version 1.6.x.");
                }

                throw var8;
            } catch (Exception var9) {
                failedBinding(var9);
                throw new IllegalStateException("Unexpected initialization failure", var9);
            }
        } finally {
            postBindCleanUp();
        }

    }
```

findPossibleStaticLoggerBinderPathSet 方法中，首先获取日志工厂，然后通过路径查找。根据路径可得知：查找所有slg4j标准接口的实现。

```java
private static String STATIC_LOGGER_BINDER_PATH = "org/slf4j/impl/StaticLoggerBinder.class";
static Set<URL> findPossibleStaticLoggerBinderPathSet() {
        LinkedHashSet staticLoggerBinderPathSet = new LinkedHashSet();

        try {
            ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();
            Enumeration paths;
            if (loggerFactoryClassLoader == null) {
                paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);
            } else {
                paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);
            }

            while(paths.hasMoreElements()) {
                URL path = (URL)paths.nextElement();
                staticLoggerBinderPathSet.add(path);
            }
        } catch (IOException var4) {
            Util.report("Error getting resources from path", var4);
        }

        return staticLoggerBinderPathSet;
    }
```

注意，StaticLoggerBinder类地址的存储对象是一个set集合，避免多个系统都引入该日志系统，从而报错。

查看日志系统jar包中，确实存在该文件。

![image-20230414102500140](京东.assets/image-20230414102500140.png)



![image-20230414102734043](京东.assets/image-20230414102734043.png)

reportMultipleBindingAmbiguity方法，会在系统启动时标红，因为系统启动包含多个日志系统的绑定实现。

```java
    private static void reportMultipleBindingAmbiguity(Set<URL> binderPathSet) {
        if (isAmbiguousStaticLoggerBinderPathSet(binderPathSet)) {
            Util.report("Class path contains multiple SLF4J bindings.");
            Iterator var1 = binderPathSet.iterator();

            while(var1.hasNext()) {
                URL path = (URL)var1.next();
                Util.report("Found binding in [" + path + "]");
            }

            Util.report("See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.");
        }

    }
```

在bind()方法后面，会选择绑定实现的其中一个进行执行获取。 StaticLoggerBinder.getSingleton();

```java
private static final void bind() {
        try {
            String msg;
            try {
                Set<URL> staticLoggerBinderPathSet = null;
                if (!isAndroid()) {
                    staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();
                    reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);
                }

                StaticLoggerBinder.getSingleton();
                INITIALIZATION_STATE = 3;
                reportActualBinding(staticLoggerBinderPathSet);
            } catch (NoClassDefFoundError var7) {
                /**/
            }
        } finally {
            postBindCleanUp();
        }

    }
```

获取StaticLoggerBinder后，不同的StaticLoggerBinder中的loggerFactory实现不同，拿到日志工厂后，再调用getLogger获取logger对象进行日志输出。



整体梳理，

若系统中，无论是本系统还是引用的jar包，有多个日志系统实现，会根据日志系统的适配层选择其中一个执行获取。jar包会选择它代码中日志bingder选择日志系统实现。

- 通过LoggerFactory.getLogger(Object.class); 获取日志对象
  - 获取日志工厂getLoggerFactory()
    - 其内部调用performInitialization();执行初始化方法，主要是执行bind()方法，绑定相应的日志系统StaticLoggerBinder，
      - 执行findPossibleStaticLoggerBinderPathSet()方法，通过STATIC_LOGGER_BINDER_PATH 固定路经，通过set集合保存，多个jar包下均存在该实现。
      - 执行reportMultipleBindingAmbiguity()方法，报告存在多个日志实现
      - 执行StaticLoggerBinder.getSingleton();获取其中一个
      - reportActualBinding(staticLoggerBinderPathSet); 报告绑定的日志
    - 不同的StaticLoggerBinder中，获取loggerFactory的实现不同。
  - 通过工厂调用getLogger，获取logger

# 链路追踪

单系统的链路追踪可以使用AOP实现。

由于分布式架构，链路追踪的困难点在于 请求链路A->B->C->D，每个服务有多台机器，若链路出现问题，无法得知具体的服务，和机器等

痛点：

1. 排查问题难度大，周期长
2. 特定场景难复现
3. 系统性能瓶颈分析较难

OpenTracing是链路追踪的标准。

OpenTracing包含三个变量：

- Trace：整个请求链路
- Span：调用过程（包含请求的开始时间和结束时间）
- SpanContext：Trace的全局上下文信息，包含TraceId（链路之间的区分标志）



链路追踪系统有个collector在收集每个点上的数据，数据包括

- 全局 trace_id：同一个链路，trace_id相同
- span_id: 当前节点的id，和parent_span_id来联系哪个调用
- parent_span_id：

还可以记录一些其他信息，比如发起调用服务名称、被调服务名称、返回结果、IP、调用服务的名称等，最后，链路追踪系统再把相同spanid的信息合成一个大的span块，collertor根据trace_id构建出完整的调用链。

数据列表

![img](京东.assets/v2-66741162e792854331c650a305cd887c_720w.jpeg)

可视化界面

![img](京东.assets/v2-6e85c926f70b831374aab9cfb1e68f96_720w.jpeg)

## 存在的问题：

- 怎么自动采集 span 数据：自动采集，对业务代码无侵入
  - 插件化的方式进行span数据的自动采集，实现对代码的无侵入性
- 如何跨进程传递 context
  - 数据传输分为请求头header和请求体body，将context所有数据序列化添加到请求头handler中，传递context流程均由插件执行，业务无感知。不应把context放在请求体body中，因为body中存放着业务数据，不方便处理。
- traceId 如何保证全局唯一
  - 分布式生成ID或者本地生成ID，分布式ID，需要获取时，发送一个请求。本地生成ID则选择雪花算法。
  - 雪花算法缺点：由于雪花算法是根据时间生成ID，缺点是时间回拨。若发现时间回拨，即当前生成的ID比上次的ID值小，则可以生成一个随机数作为Trace_id
- 请求量这么多采集会不会影响性能
  - 若每个请求都采集，则数据量巨大，且影响性能。可以**采样部分数据**。但可能出现请求链路中A->B->C->D，对A进行了采样，B未必采样。解决方式可以是，上游若携带context数据，则下游必须采集数据。
  - 采样部分数据，即采样率，意味着无法记录所有请求的数据。



## 线程池，异步线程执行时，traceID丢失问题

**疑问：**web服务可以通过header中设置traceId在不同服务中传递，而在服务中，多线程异步执行，traceId也可能存在不一致的问题。很多时候，traceId保存在threadLocal中，异步执行时，则threadlocal中的数据丢失。

**前置知识：**InheritableThreadLocal,Thread.class中声明的变量

```java
    /*
     * InheritableThreadLocal values pertaining to this thread. This map is
     * maintained by the InheritableThreadLocal class.
     */
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
```

在子线程创建时，会将父线程的inheritableThreadLocals赋值到子线程中。而线程池没有完成 该代码。

```java
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc,
                      boolean inheritThreadLocals) {
        /** 。。。 */
      if (inheritThreadLocals && parent.inheritableThreadLocals != null)
            this.inheritableThreadLocals =
                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
        /** 。。。 */
    }
```



**问题表述：**当一个线程执行过程中，开启了新的一步线程，会导致异步线程和当前线程的traceid不一致。异步线程与当前线程的traceId不一致。线程TraceId在线程创建时，就已经确定的，而且线程池在线程复用时，都是该traceID，造成traceID混乱。

**最终导致异步线程在日志中，无法准确追踪整个调用链路。**

Zipkin的解决方案：

有个专门的TtlRunnable和TtlCallable包装类，用于读取原Thread的ThreadLocal对象及值并存于Runnable/Callable中，在执行run或者call方法的时候再将存于Runnable/Callable中的ThreadLocal对象和值读取出来，存入调用run或者call的线程中。





# 阿里 Java开发规范

## 不要用一个常量类维护所有常量

不要用一个常量类维护所有常量，需要按常量功能进行分类，分开维护

大而全的常量类，杂乱无章，若是根据查找功能才能定位到修改的常量信息，不利于理解和维护

## 命名

- 包的命名都是小写，且单数不能是复数。 
- 类的名字可以是复数，并且要求驼峰表达式
- 枚举的命名是以Enum结尾，并且枚举值都是大写
- 领域模型，DTO等都是大写
- 若是模块。类、方法 使用了设计模式，需要在命名时体现  （xxxFactory）





## 公共常量分为多个层次

1. 外部应用共享的常量
2. 应用内所有工程可查看下的公共常量
3. 子工程下的公共常量
4. 包内的共享常量
5. 类内共享常量

**严格区分 对内和对外的常量**



## 禁止使用 BigDecimal(double) 将小数转换为BigDecimal

BigDecimal 是java 表示精确浮点数运算的类，double虽然也可以表示小数，由于二进制无法准确表示0.1，，需要转换成8字节的double，而且是八字节（指定了字节长度），所以编译器选择用一个最接近的数来表示0.1，即0.1000000000000000055511151231257827021181583404541015625。因此 new BigDecimal(0.1)会变成上面的字符串。究其真正原因是 **double无法真正表示小数，所以进行了四舍五入，舍弃了部分精度。**

用String 就可以避免这个问题

## 定义DO、VO、DTO类

- 不设置默认值
- 使用对象，不使用基本数据类型

## 并发修改同一记录，避免更新丢失，需要加锁。

数据库加锁，使用乐观锁， 使用version作为更新一句

该乐观锁 version还可以保证与redis和ES的版本一致性



## if 不要超过三层嵌套

超过三层，则方法后续维护困难



## 单表超过500万行或者单表容量超过2GB才推荐分库分表

若是预计三年后的数据量达不到和这个级别，则不必在创建时就分库分表。实际上现在单表已经能够支撑千万级的数据查询。



## 不要使用 count(列名)或count(常量)

Count(列名)或者count(常量) 不会统计 该列为null的值，count(*) 会统计为null的行



## sql.xml 使用 #{}，不要使用${}

- #{}是设置变量参数，先设为？再通过PreparedStatement进行赋值，能够很大程度防止sql注入
- ${} 实质是字符串拼接，若是拼接实名，则通过${}，尽量不使用${}



## @Transactional 事务不要滥用

单表操作不必使用事务，



## 线上应用不要依赖 SNAPSHOT版本

不依赖SNAPSHOP版本是保证应用发布的幂等性  

SNAPSHOT版本包可以多次发包， 1.2.1 只能发布一次

## 在线上生产环境， JVM 的 Xms 和 Xmx 设置一样大小的内存容量， 避免在 GC 后调整堆大小带来的压力。

oracle 官方推荐

- -Xms: 堆内存的最小值，
- -Xmx: 堆内存的最大堆内存值

**为什么要设置为一致值？**

**垃圾回收 GC**

在堆内存使用情况变化时，不会直接扩大或缩小堆内存，而是先执行Full Gc，若是Gc无法释放更多内存时，才会进行内存的拓展。也就是说内存不足导致的频繁的GC会不断地影响系统性能，更别说Stop the world了

**相同值的好处**

为避免在生产环境下 heap 内存扩大或缩小影响机器性能。

**生产环境，一般都是一台机器部署一个程序实例，动态调整内存大小，反倒意义不大。更适合指定堆内存大小相同**

不过，JDK有多种垃圾回收器，不同垃圾回收器还需要酌情考虑。





# JAVA序列化和反序列化

- java序列化：将JAVA对象转换为字节序列的过程
- java反序列化：将字节序列恢复为java对象的过程（此时数是创建新的对象）



# 流量录制和回放

某个时间段内，通过流量录制平台将请求到A应用的所有请求录制下来，并将这些请求回放给B应用，验证代码的正确性。

**意义：**研发团队因为流量复杂（请求构建成本高），业务复杂（业务场景梳理困难），服务复杂（服务调用复杂），通过记录线上流量，在开发或者测试环境回放，来发现系统是否能够正常运行，降低代码变动给整个系统带来的风险。

## 为什么不直接构造请求，测试接口？

常规的请求过于简单，而且大多是常规的请求，另外环境依赖过多。

- 测试用例编写难，数据构造难，用户真实的使用行为不容易模拟

- 测试脚本通过测试脚本难以严重，例如发送消息无法验证消息内容没有问题

- 严重依赖人工测试，若人工未能考虑到所有场景，则容易出现线上问题

  

流量录制过程：一条完整的调用链路包括入口调用和若干次的子调用。录制时，通过traceId（链路追踪时的唯一标识）绑定成一条完整的调用记录。然后平台进行记录，存储。



# 定时任务

定时任务的场景特别多，但触发方式大概有三种：

1. 延迟一定时间后执行
2. 固定周期定时执行
3. 指定某个时刻执行

JDK提供了三种定时器实现方式：

1. Timer
2. DelayedQueue
3. ScheduledThreadPoolExecutor

## 执行方式

### Timer

Timer是Java早期版本实现，可以实现固定周期的任务、以及延迟任务。Timer 会启动一个异步先吃去执行任务，任务只会被执行一次，也可以周期性执行多次（实际也是执行了一次，无非是执行了一次后又添加了新的相同任务）

执行方式：

```java
Timer timer = new Timer();

timer.scheduleAtFixedRate(new TimerTask() {
    @Override
    public void run() {
        // do something
    }
}, 10000, 1000);  // 10s 后调度一个周期为 1s 的定时任务
```

任务是由TimerTask类实现，TimerTask 实现了Runnable接口的抽象类，timer负责调度和执行任务

**Timer 内部构造**

```java
public class Timer {

    private final TaskQueue queue = new TaskQueue();

    private final TimerThread thread = new TimerThread(queue);
    public Timer(String name) {
        thread.setName(name);
        thread.start();
    }
}
```

TaskQueue 是数组结构的小根堆（完全二叉树，根节点在整个堆中是最小的元素），根节点是deadline 最近的任务。

Timer内部有个TimerThread异步线程，TimerThread定时轮询TaskQueue，只取根节点就可，到期执行，执行结束后，删除该节点。若是周期性任务，执行完成后，计算下一次任务的deadline，再次插入到TaskQueue。

**Timer 缺点**

- Timer是单线程模式，若是任务执行时间太久，会影响其他任务调度
- Timer是基于绝对时间，若是系统时间不准确，可能会有问题
- Timer不会捕获执行异常，线程会停止，后续任务无法执行



### DelayedQueue

DelayedQueue 延迟获取对象的阻塞队列，任务使用优先级队列存储对象。

DelayedQueue的任务都必须实现Delayed接口，重写compareTo（比较优先级）和getDelay方法（计算延迟消息的剩余时间）。



```java
        BlockingQueue<SampleTask> delayQueue = new DelayQueue<>();

        long now = System.currentTimeMillis();
        delayQueue.put(new SampleTask(now + 1000));
        delayQueue.put(new SampleTask(now + 2000));
        delayQueue.put(new SampleTask(now + 3000));
        for (int i = 0; i < 3; i++) {
            System.out.println(new Date(delayQueue.take().getTime()));
        }

```



DelayQueue在日常开发中最常用的场景是实现**重试机制**。接口调用失败或者请求超时后，可以把当前对象放在DelayQueue，通过异步线程重试，失败再次放在DelayQueue。可以设置重试的最大次数和采用指数退避算法设置对象的deadline，2s、4s、8s、16s......以此类推



### ScheduledThreadPoolExecutor

ScheduledThreadPoolExecutor就是为了替换Timer，继承ThreadPoolExecutor。

任务 ScheduledFutureTask 和阻塞队列 DelayedWorkQueue。任务可执行延时任务和周期任务，阻塞队列是优先级队列，deadline最近的任务在队列头部。周期性任务在执行完会重新设置时间，再次放入阻塞队列。

```java
public class ScheduledExecutorServiceTest {
    public static void main(String[] args) {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);
				// 1s 延迟后开始执行任务，每 2s 重复执行一次
        executor.scheduleAtFixedRate(() -> System.out.println("Hello World"), 1000, 2000, TimeUnit.MILLISECONDS); 
    }
}
```



## 时间轮原理分析

实际生产中，存在大量定时任务，一个优先级队列会有严重的性能瓶颈，使用时间轮。分为多个slot槽位，每个slot代表一个时间段，每个slot存放多个任务。slot是定时任务执行的时间的最小粒度。每个slot操作保存的是链式结构。

任务添加到时间轮中，按任务的到期时间取模，放在不同的slot槽位。1s，9s都放在slot 0槽位。第一圈在槽位0时，只执行1s的任务。到第二圈才执行9s的任务。任务记录 到期时间，圈数，槽位。 执行时间 = 圈数 * 8 + 槽位；

若是任务数量比较多的场景，可以增减slot槽位，减少时针转动遍历的任务数。时间轮定时器最大的优势就是，任务的新增和取消都是 O(1) 时间复杂度，而且只需要一个线程就可以驱动时间轮进行工作。

![img](京东.assets/d522be999fba0cb9e38f7afa1a2ad437.png)

























































































