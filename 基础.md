# java 优雅

## 用流更优雅

```java
for (Message message : messageList) {
		......                        
}
```

改为

```
messageList.forEach(message ->
		......     
);
```

==**stream的filter是过滤掉为false的对象**==

## null和empty()判断

```Java
CollectionUtils.isNotEmpty(messageList) // 既判断null，也判断empty（）
Objects.nonNull() & Objects.isNull() // 判断null
StringUtils 。。。 // 大同小异，用jd的包
  
```

## 构造器

@NoArgsConstructor 无构造器注解

@AllArgsConstructor 全构造器注解

## Try-catch异常打印

**不要使用e.printStackTrace()**,只是打印到控制台，并且过多占用内存空间

建议使用以下方式

```java
try{
  xxxx
}catch (Exception e) {
	log.error("xxx错误，阿巴阿巴xxx", e.getMessage());
	/*也可以e.getCause().getMessage()
	在getMessage()获取异常名称的基础上，
	添加了异常原因
	e.getMessage()是将错误打印至error.log日志文件中
	*/
}
```

## Optional

工具类，与stream功能类似，主要应用于object对象，而非集合

**Optional.ofNullable**(T value) ：传入参数，若为null，则返回Optional.empty()

- 内部相关方法

  - **ifPresent**：如果存在，则执行内部方法。

    - ```java
      Optional.ofNullable(getUserById(id)).ifPresent(()->{xxxxx});
      ```

    ```java
    Optional<User> user = Optional.ofNullable(getUserById(id));
    user.ifPresent(u -> System.out.println("Username is: " + u.getUsername()));
    ```

  - **orElse**: 如果optional没有值，返回orElse 方法传入的参数

    - ```java
      User user = Optional
              .ofNullable(getUserById(id))
              .orElse(new User(0, "Unknown"));
      ```

  - **orElseGet**：与orElse()区别，可以穿入参数

  - **orElseThrow**：在方法内部抛出异常

  - **map**：可以多次map，与stream类似，输出值

  - **filter**：过滤，==为true时通过，false滤除==

  - 例子：

    ```java
    Optional<String> username = Optional
            .ofNullable(getUserById(id))
            .filter(user -> user.getId() < 10)
            .map(user -> user.getUsername());
    ```




## 断言

阿里规范中，强制单元测试中，不能使用sout手动比对，而是使用断言。

，满足条件才能继续运行，若不满足条件，则出现异常

Assert.assertEquals

Assert.assertTrue



# 多线程

## 异步编排

### CountDownLatch

**CountDownLatch是一个工具类，用来协调多个线程间的同步。CountDownLatch能等待其他的一些线程完成工作后，再执行相应的代码。通过一个计数器完成。**计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成一些任务，然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。

**CountDownLatch的用法**

- 用法一：某个线程在开始运行前等待n个线程执行完毕，首先创建初始化new CountDownLatch(n),每个任务执行完毕后，将计数器减一，countdownLatch.countDown()。当计数器的值变为0后，在Count DownLatch上await()的线程就被唤醒。
  - 用于等待多个任务执行结束后，再继续执行。（任务数不固定，无法使用CompletableFuture异步编排）
- 用法二：做法初始化一个共享的CountDownLatch(1),将其计算器值设为1，多个线程在开始任务前首先countdownlatch.await()，当主线程调用countDown()时，计数器变为0，多个线程同时被唤醒。
  - 用于要求多个线程同时并行执行

**CountDownLatch的不足**

CountDownLatch是一次性的，计算器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。



### **CompletableFuture**

==**为什么使用异步编排？**==

- 将两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。此时需要异步编排。（若是结果不相互依赖，直接异步即可，没必要异步编排）
- 查询商品详情页的逻辑复杂，有些数据需要远程调用。必然花费更多时间。可以使用线程池，异步获取数据，进行编排提高响应速度。
- 例如：进入商品详情页（携带skuId）
  1. 获取SKu的基本信息    异步1
  2. 获取SKU的图片信息    异步1
  3. 获取SKU的促销信息     异步1
  4. 获取spu的所有销售属性   需要等待查询到（获取SKu的基本信息中的spuId）才能获取spuId     异步2
  5. 获取规格参数  异步2
  6. 获取spu详情    异步2
- 原本需要等待6个请求时间累加，变为两次异步操作的时间，极大的提高了响应时间。





jdk1.8，添加了CompletableFuture，进行异步编排。

将两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。此时需要异步编排。

- ### 创建异步对象

  - 没返回值runAsync

    ```Java
            ExecutorService executor = newFixedThreadPool(10);
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                System.out.println(Thread.currentThread().getId());
            }, executor);
    ```

  - 有返回值supplyAsync

    ```Java
    CompletableFuture<Long> future = CompletableFuture.supplyAsync(() -> {
                long id = Thread.currentThread().getId();
                System.out.println(id);
                return id;
            }, executor);
            Long aLong = future.get();
    ```

- ### 线程执行完成的回调方法

  - whenComplete(BiConsumer<? super T,? super Throwable> action);
    - 在线程执行完成后，将返回值和异常，进行操作，T为线程执行结果，action为异常信息。
  - exceptionally(Function<Throwable,? extends T> fn);
    - 线程出现异常，优先进入该方法，可以设置返回值，使得即使异常也会有返回值
  - whenComplete与exceptionally一块执行，若出现异常，先执行exceptionally，再执行whenComplete

whenComplete 和 whenCompleteAsync 的区别：
		whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。
		whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。

- ###  线程串行化方法

  ​	（即一个线程执行结束，再执行下一个线程）

  - thenRun，thenRunAsync方法：上一个线程结束，执行thenRun，不能获取上一个线程的结果，也不能有返回值
  - thenAccept，thenAcceptAsync：能获取上一个线程的结果进行操作，但不能有返回值
  - thenApply，thenApplyAsync：能获取上一个任务的结果，并返回当前值

```Java
        ExecutorService executor = newFixedThreadPool(10);
        CompletableFuture<Long> future = CompletableFuture.supplyAsync(() -> {
            long id = Thread.currentThread().getId();
            System.out.println(id);
            return id;
        }, executor).thenApplyAsync(res->{
            return res*2;
        },executor);
        Long aLong = future.get();
        System.out.println(aLong);
```

- ### 多任务组合

  - allOf：等待所有任务完成

  - anyOf：只要有一个任务完成。返回值调用anyof方法，可以获取率先执行结束线程的结果

    ```Java
    public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs);
    
    public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs);
    ```

  - 注意：这两个方法调用，要使用get();,否则在anyof中不能，达到any的目的


    ```Java
            CompletableFuture<Void> all = CompletableFuture.allOf(future1, future2, future3);
            all.get();
    ```

# MySql

## 批量将分组后数据排序，然后取第一条数据

```sql
select * from (select distinct(a.id) tid, a.* from template_detail a
               where a.template_id in (3, 4)
              order by a.id desc) tt
group by tt.template_id;
```

步骤：先进行排序（排序时where过滤），再进行分组，会自动获取分组后的第一条数据

- **==distinct(a.id)==**为什么是distinct呢？
  - 为了避免合并中使用derived_merge。（合并的构造）

derived_merge：指的是一种查询优化技术，作用就是把派生表合并到外部的查询中，提高数据检索的效率。这个特性在MySQL5.7版本中被引入。

虽然看着吊但是不好用且容易出错。

子查询调用下面操作可以关闭该优化操作：

```sql
可以通过在子查询中使用任何阻止合并的构造来禁用合并，尽管这些构造对实现的影响并不明确。 防止合并的构造对于派生表和视图引用是相同的：
   1.聚合函数（ SUM() ， MIN() ， MAX() ， COUNT()等）
   2.DISTINCT
   3.GROUP BY
   4.HAVING
   5.LIMIT
   6.UNION或UNION ALL
   7.选择列表中的子查询
   8.分配给用户变量
   9.仅引用文字值（在这种情况下，没有基础表）

```

如果没有distinct，子查询中的order by失效。加上distinct则结果正确。临时表中使用order by，为使其生效，则需要满足三个条件

- 外部查询禁止分组或者聚合
- 外部查询未指定`having，HAVING， order by`
- 外部查询将派生表或者视图作为`from`句中唯一指定源

不满足全部条件，则order by会被忽略。原因在于derived_merge优化后不会执行filesort操作，所有order by失效。所以添加distinct。





# Spring：

## @Qualifier 注解

根据名称进行注入，避免了通过类注入时，有多个同一类。下面代码会报错。

```
 @Component("fooFormatter")
    public class FooFormatter implements Formatter {
        public String format() {
            return "foo";
        }
    }

    @Component("barFormatter")
    public class BarFormatter implements Formatter {
        public String format() {
            return "bar";
        }
    }

    @Component
    public class FooService {
        @Autowired
        private Formatter formatter;
        
        //todo 
    }
```

需要该操作

```
 @Component
     @Qualifier("fooFormatter")
     public class FooFormatter implements Formatter {
         public String format() {
             return "foo";
         }
     }
 
     @Component
     @Qualifier("barFormatter")
     public class BarFormatter implements Formatter {
         public String format() {
             return "bar";
         }
     }

    @Component
    public class FooService {
        @Autowired
        @Qualifier("fooFormatter")
        private Formatter formatter;
        
        //todo 
    }
```

## @Bean注解

@Bean 注解方法时，参数 是通过 @Autowrited 注解方式，进行自动注入的

```java
	@Bean
	public MyBeanTest MyBeanTest(@Qualifier(value="mytest") Mybean mytest){
		return MyBeanTest (mytest);
	}
```



## 读取配置文件值

yml配置文件

```
api:
  mes:
    MES_SOCKET: http://192.168.99.140:8081
```

### 方法一

方法一优雅

```
@Component
@ConfigurationProperties(prefix = "api.mes")
public class MesApiConfig {

    /**
     * 读取yml下配置好的api-mes——socket
     */
    private String MES_SOCKET;
   
}
```

方法二

```
@Component
public class MesApiConfig {

    /**
     * 读取yml下配置好的mes——socket
     */
    @Value("${api.mes.MES_SOCKET}")
    private String MES_SOCKET;

}
```





# 阿里 Java开发规范