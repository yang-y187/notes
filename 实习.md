职场与学校不同

- **自驱力，主动性**，定计划，制定中短期计划（可以找导师订）。深挖一个或两个小方向（）。对其他的方向熟悉。
- 不能被业务需求裹挟
- 熟悉一个需求怎么出现



先列出问题，等开会的时候或者和导师约个时间来问。



# 学习

- thrift
  - thrift是一个**跨语言**，的rpc框架。使用中间语言IDL来转换请求。
    thrift最大的优点就是跨语言。
  - ![image-20220526104728594](%E5%AE%9E%E4%B9%A0.assets/image-20220526104728594.png)
  - **为什么使用IDL？**
    - 因为thrift是跨语言的，支持多语言的转换，所以自己构建了一种语言，来处理。
  - **讲讲IDL数据结构？**
    - 数据结构选择所有语言有支持的部分，比如说：基本数据类型为有符号的，java支持无符号数，我猜测是thrift支持的语言可能有的只支持有符号数。
  - **RPC与普通http协议区别：**
    - HTTP协议在应用层完成的，但有时效率并不高效；
    - RPC可以不依赖于应用层协议，可以直接基于TCP进行远程调用，在传输层中即可完成通信，因此更适于某些对效率要求更高的场景。



# MTThrift

- thrift都是service层之间的调用。与controller层无关

- controller层的配置都设置在网关，直接调用service。

  

# ElasticSearch

分布式的开源搜索和分析引擎。

- 为什么不使用MySQL进行搜索？
  - MySQL主要功能是数据的持久化和管理。对海量数据的搜索分析，Es更专业。
  - MySQL 本身不支持全文搜索，只有模糊查询，而且是全表扫描，查询效率低下。
  - MySQL 对于复杂条件查询的支持并不好，MySQL 最多使用一个条件涉及的索引来过滤，若过滤条件为多个字段，且都有索引，那MySQL只能选择索引进行使用，其他字段当做普通过滤条件。

## 概念

动名词对应

index（索引）

| Es               | MySQL                                              |
| :--------------- | -------------------------------------------------- |
| Index(索引)      | 动词：MySQL中的insert<br />名词：MySQL中的Database |
| Type（类型）     | 表                                                 |
| Document（文档） | 表中的内容（JSON格式）                             |

![image-20220526171436588](%E5%AE%9E%E4%B9%A0.assets/image-20220526171436588.png)



**倒排索引**

1. 将存储的内容进行分词
2. 每个词，可能有多条记录对应。
3. 检索时：会将要检索的内容也进行分词，只要有一个分词与es存储的词对应，则可以搜索出该词所有记录。顺序方面，对应的词越多，则顺序越靠前
4. 相关性分析：若对应的词个数相同，则记录内容总词数越少，顺序越靠前





![image-20220526184755934](%E5%AE%9E%E4%B9%A0.assets/image-20220526184755934.png)

使用kibana来访问es，类似SQLyog访问MySQL

## 初步

1，_ _ cat

GET /_cat/nodes：查看所有节点
GET /_cat/health：查看 es 健康状况
GET /_cat/master：查看主节点
GET /_cat/indices：查看所有索引 show databases;

2，索引一个文档（保存一个记录）

http://192.168.56.10:5601/app/kibana  在kibana网址进行检索。

## Query DSL

### 1，基本语法格式

```elm
GET /bank/_search   // 查询操作
{
  "query": {   // 查询所有
    "match_all": {}
  },
  "sort": [   // 排序操作
    {
      "account_number": {
        "order": "desc"
      }
    }
  ]
}
```

响应结果

```
响应结果解释：
took - Elasticsearch 执行搜索的时间（毫秒）
time_out - 告诉我们搜索是否超时
_shards - 告诉我们多少个分片被搜索了，以及统计了成功/失败的搜索分片
hits - 搜索结果
hits.total - 搜索结果
hits.hits - 实际的搜索结果数组（默认为前 10 的文档）
sort - 结果的排序 key（键）（没有则按 score 排序）
score 和 max_score –相关性得分和最高得分（全文检索用）
```

Elasticsearch 提供了一个可以执行查询的 Json 风格的 DSL（domain-specific language 领域特定语言）。这个被称为 Query DSL。该查询语言非常全面。

- 查询语句经典结构

{
	QUERY_NAME: {      // 查询字段
			ARGUMENT: VALUE,   // 字段名  ，操作
			ARGUMENT: VALUE,...
	}
}

-  如果是针对某个字段，那么它的结构如下：

{
	QUERY_NAME: {    // 查询字段 
		FIELD_NAME: {   // 查询范围
			ARGUMENT: VALUE,
			ARGUMENT: VALUE,...
		}
	}
}

```elm
GET /bank/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "balance": {
        "order": "desc"
      }
    }
  ],
  "from": 0,
  "size": 20
}
```

- query：定义如何查询
  - match_all 查询类型，all表明查询所有，es中多种查询方式
- 与query并列的操作还有 sort 排序（可以多字段排序），from起始位置 ，size查询大小

### 2，返回部分字段

默认查询数据返回符合该条件的文档的所有内容， `_source`可以指定返回的内容。与query，sort，from同级

```elm
GET /bank/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "balance": {
        "order": "desc"
      }
    }
  ],
  "from": 0,
  "size": 20,
  "_source": ["age","balance"]
}
```

### 3 ，match【匹配查询】

- 精确查询（基本类型（非字符串）是精确匹配）

  - ```elm
    GET /bank/_search
    {
      "query": {
        "match": {
          "age":20
        }
      }
    }
    ```

- 模糊查询 （字符串类型是模糊查询，全文检索）

  - ```elm
    GET /bank/_search
    {
      "query": {
        "match": {
          "address": "Mill"
        }
      }
    }
    ```

  - **模糊查询是全文检索，会按评分进行查询排序，对检索条件进行分词匹配**。即match当查询字符串类型的时候，会进行全文 检索，并记录每条记录的相关性得分。输出时排序。

- 多词的模糊匹配

  - ```elm
    GET bank/_search
    {
      "query": {
        "match": {
          "address": "mill road"
        }
      }
    }
    ```

  - 查询时，会首先将条件进行分词。然后会对分词`road`  ，分词  `mill`  和分词 `road mill`的所有记录进行相关性得分。

### 4，match_phrase 【短语匹配】

由于多词的模糊 匹配，若我们需要将多词作为一个整体查询，而不将它分词。所以进行短语匹配

```elm
GET bank/_search
{
  "query": {
    "match_phrase": {
      "address": "mill road"
    }
  }
}
```

### 5，multi_match 【多字段匹配】

可能在查询时，可以选择多个字段 匹配该条件。

```elm
## 条件是：查询在address或city中进行模糊匹配。
GET bank/_search
{
  "query": {
    "multi_match": {
      "query": "mill road",
      "fields": ["address","city"]
    }
  }
}
```

### 6，bool【复合查询】

可以合并其他查询语句，包括符合查询（符合语句之间可以相互嵌套）

- must：必须达到must列举的所有条件
- must_not:必须不是指定的情况
- should：最好达到should列举的条件，满足会增加相关性评分

```
GET bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "multi_match": {
            "query": "mill road",
            "fields": [
              "address",
              "city"
            ]
          }
        }
      ],
      "must_not": [
        {
          "match": {
            "age": 25
          }
        }
      ],
      "should": [
        {
          "match": {
            "email": ".com"
          }
        }
      ]
    }
  }
}
```

### 7，filter【结果过滤】

match可以分词匹配，然后进行相关性判断。所以，可以选择filter过滤。**不计算分数。**filter与must。must_not同级别。

```
GET bank/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "multi_match": {
            "query": "mill road",
            "fields": [
              "address",
              "city"
            ]
          }
        }
      ]
    }
  }
}
```

### 8，term匹配

term也是匹配某个属性的值。但建议全文检索（字符串）字段用match，因为涉及到全文检索，分词。若是其他字段，即精确匹配，则可以使用term。term不能完成全文检索，所以不能使用term进行全文检索

### 9，聚合分析

执行执行搜索，并返回结果，对搜索结果进行聚合分析。即求查询结果的平均值，聚合分析等等。可以进行嵌套。

例子：

- 搜索 address 中包含 mill 的所有人 的年龄分布以及平均年龄，但不显示这些人的详情。（即两个并列聚合查询）

```elm
GET bank/_search
{
  "query": {
    "match": {
      "address": "mill"
    }
  },
  "aggs": {    ## 开启聚合分析
    "group_by_age": {   ## 给该聚合分析命名
      "terms": {    ## 聚合方式
        "field": "age",
        "size": 10
      }
    },
    "avg_age": {
      "avg": {
        "field": "age"
      }
    }
  },
  "size":0    ## size=0 表示只查看聚合信息
}
```

- 按照年龄聚合，并且请求每个年龄段的这些人的平均薪资

```elm
GET bank/_search
{
  "query": {
    "match": {
      "address": "mill"
    }
  },
  "aggs": {
    "group_by_age": {
      "terms": {
        "field": "age",
        "size": 10
      },
      "aggs": {
        "avg_balance": {
          "avg": {
            "field": "balance"
          }
        }
      }
    },
    "avg_age": {
      "avg": {
        "field": "age"
      }
    }
  },
  "size":0
}
```

## 映射 Mapping

映射：定义字段的类型，与MySQL建表时，定义字段类型。相似

Mapping（映射）
Mapping 是用来定义一个文档（document ），以及它所包含的属性（field ）是如何存储和
索引的。比如，使用 mapping 来定义：

- 哪些字符串属性应该被看做全文本属性（full text fields）。
- 哪些属性包含数字，日期或者地理位置。
- 文档中的所有属性是否都能被索引（_all 配置）。
- 日期的格式。
- 自定义映射规则来执行动态添加属性



### 1，创建映射

查看 mapping 信息

```elm
GET bank/_mapping
```

创建新的索引，并指定映射关系

```elm
PUT /my_index
{
  "mappings": {
    "properties": {
      "age": {"type": "integer"},
      "email":{"type": "keyword"},
      "name":{"type": "text"}
    }
  }
}
```

### 2，添加新的映射

```elm
PUT /my_index/_mapping
{
  "properties": {
    "employee-id": {
      "type": "keyword",
      "index": false    ##  false 表示不能被检索
    }
  }
}
```

### 3，更改映射信息

对已经存在的映射不能更改，但是可以创建新的映射 ，并进行数据迁移

### 4，数据迁移

```elm
POST _reindex
{
  "source": {
    "index": "twitter"
  },
  "dest": {
    "index": "new_twitter"
  }
}
```



## 3，Spring 整合es

Elasticsearch-Rest-Client

es配置

```java
@SpringBootConfiguration
//@Configuration
public class mallElasticSearchConfig {

    public static final RequestOptions COMMON_OPTIONS;
    static {
        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();
//        builder.addHeader("Authorization", "Bearer " + TOKEN);
//        builder.setHttpAsyncResponseConsumerFactory(
//                new HttpAsyncResponseConsumerFactory
//                        .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));
        COMMON_OPTIONS = builder.build();
    }


    @Bean
    public RestHighLevelClient esRestClient(){
        RestHighLevelClient client = new RestHighLevelClient(
                RestClient.builder(new HttpHost("192.168.56.10", 9200, "http")));
        return  client;
    }
}

```

### 保存与更新数据

方式一：

```java
    @Resource
    private RestHighLevelClient client;

    @Test
    public void test1() throws IOException {
        System.out.println(client);
        // 构建索引
        IndexRequest indexRequest = new IndexRequest("user11");
       //设置ID，默认也会自动生成，且自增
        indexRequest.id("1");
        indexRequest.source("userName","www","gender","男","age","16");

        IndexResponse index = client.index(indexRequest, mallElasticSearchConfig.COMMON_OPTIONS);
    }
```

- 方式二

```java 
    @Resource
    private RestHighLevelClient client;

    @Test
    public void test1() throws IOException {
        System.out.println(client);
        // 构建索引
        IndexRequest indexRequest = new IndexRequest("user11");
        // 使用JSON格式
        User user = new User();
        user.setUserName("www");
        user.setAge(18);
        user.setGender("女");
        String s = JSON.toJSONString(user);
        indexRequest.source(s,XContentType.JSON);
        
        IndexResponse index = client.index(indexRequest, mallElasticSearchConfig.COMMON_OPTIONS);
    }
```

### 复杂检索

```java
    public void test2() throws IOException {
        // 1,创建检索请求
        SearchRequest searchRequest = new SearchRequest();
        // 指定索引
        searchRequest.indices("bank");
        // 指定DSL，检索条件
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        // 查询
        //sourceBuilder.query();
        // 起始位置
        //sourceBuilder.from();
        // 个数
        //sourceBuilder.size();
        // 集合分析
        //sourceBuilder.aggregation();

        // 按字段模糊查询
        sourceBuilder.query(QueryBuilders.matchQuery("address","mill"));
        // 按年龄的值分布进行聚合
        TermsAggregationBuilder ageAgg =
                AggregationBuilders.terms("aggAgg").field("age").size(10);
        sourceBuilder.aggregation(ageAgg);

        // 聚合分析，计算聚合平均薪资
        AvgAggregationBuilder balanceAgg = AggregationBuilders.avg("balanceAgg").field("balance");
        sourceBuilder.aggregation(balanceAgg);
        System.out.println("检索条件："+sourceBuilder);

        // 2,执行检索条件
        SearchResponse searchResponse = client.search(searchRequest, mallElasticSearchConfig.COMMON_OPTIONS);

        // 3,分析结果
        System.out.println(searchResponse);

        // 3.1 获取所有查到的数据
        SearchHits hits = searchResponse.getHits();
        SearchHit[] searchHits = hits.getHits();

        for (SearchHit searchHit : searchHits) {
            System.out.println(searchHit.getSourceAsString());
            // 该字符串为JSON格式。后续可以将该JSON转为对象
            // JSON.parseObject()
        }
        //  3.2 获取当前聚合信息
        // 
        Aggregations aggregations = searchResponse.getAggregations();

        Terms ageAgg1 = aggregations.get("ageAgg");
        for (Terms.Bucket bucket : ageAgg1.getBuckets()) {
            String keyAsString = bucket.getKeyAsString();
            System.out.println("年龄:"+keyAsString);
        }

        Avg balanceAgg1 = aggregations.get("balanceAgg");
        System.out.println("平均薪资:"+balanceAgg1.getValue());
    }
```



# Git

## 一.Git分支的作用

在进行多人协作开发的时候，为了防止互相干扰，提高协同开发的体验，建议每个开发者都基于分支进行项目功能的开发。

![image-20220530105129416](%E5%AE%9E%E4%B9%A0.assets/image-20220530105129416.png)

## 二：master主分支

在初始化本地Git仓库的时候，Git默认已经帮我们创建了一个名字叫做master的分支。通常我们把这个master分支叫做主分支。

![image-20220530105239162](%E5%AE%9E%E4%B9%A0.assets/image-20220530105239162.png)

 **在实际工作中，master主分支的作用是:用来保存和记录整个项目已完成的功能代码。**
**因此，不允许程序员直接在master分支上修改代码，因为这样做的风险太高，容易导致整个项目崩溃，因此我们需要在自己负责开发的分支上进行开发**

## 三.功能分支 

由于程序员不能直接在master分支上进行功能的开发，所以就有了功能分支的概念。
功能分支指的是专门用来开发新功能的分支，它是临时从master主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到master主分支上。

![image-20220530105445956](%E5%AE%9E%E4%B9%A0.assets/image-20220530105445956.png)



## 优选规范：

### 分支命名规范

**格式：feature/{需求issueId}/{简要描述}** 

- 例如：**feature/YIOFY-2020-6183419/addCityQuery 或 feature/YIOFY-6183419/addCityQuery 或  feature/6183419/addCityQuery**
- 注意：6183419为需求issueId
- 建议：在Ones系统需求中创建分支，需求issueId将自动填写于新分支名之中

## 分支创建流程

## **何时创建**

**需求流程进入到开发阶段且“待开发”、“开发中”状态创建分支**

![image-20220530105805116](%E5%AE%9E%E4%B9%A0.assets/image-20220530105805116.png)

## **在哪创建**

**进入需求详情 -- 分支 -- 点击“新建分支”**

![image-20220530105820804](%E5%AE%9E%E4%B9%A0.assets/image-20220530105820804.png)

## **分支信息**

**在新建分支弹窗，选择服务 -- 分支类型（feature）-- 描述，即可预览分支名称**

![image-20220530110005874](%E5%AE%9E%E4%B9%A0.assets/image-20220530110005874.png)

## **分支关联**

**创建后，分支自动关联到需求上，本地IDEA切换到以上分支即可开始编码**

![image-20220530110026831](%E5%AE%9E%E4%B9%A0.assets/image-20220530110026831.png)

### Idea 中切换git分支

右键git工程，进入git，选择`Branches`

![image-20220530110533836](%E5%AE%9E%E4%B9%A0.assets/image-20220530110533836.png)

# Maven 

Maven中，为什么不直接调用server而是使用client？

- 因为一个大项目是多个团队合作开发。需求也是分发给多个团队。而且需求直接可能相互调用。若是一个团队等待其他团队开发完才开发影响开发效率。所以先构建出client标准（需求规范，与java中的接口类似），不影响其他其他人的调用开发。
- 此外，降低了耦合，更加规范化。





# 慢SQL性能解析

慢SQL未必是索引失效，该例子就是，索引全部命中，可仍然很慢。线下测试数据集查不出来。线上表400w的数据，SQL执行很慢。【超过100ms则认为是慢SQL】

![image-20220606143232799](%E5%AE%9E%E4%B9%A0.assets/image-20220606143232799.png)



```sql
explain select
id,order_no,order_status,order_type,pay_mode,creator_id,creator_type,creator_name,customer_id,group_head_id,group_head_poi_id,receiver_name,receiver_contact_phone,receiver_province_id,receiver_city_id,receiver_district_id,receiver_province_name,receiver_city_name,receiver_district_name,receiver_address,cancel_operator_id,cancel_operator_type,cancel_operator_name,cancel_before_status,cancel_reason,total_price,create_time,update_time,valid,expected_delivery_time
from
  yx_order
where
  order_status = 50
  and update_time <= '2022-06-02 00:00:00'
  and valid = 1
order by
  create_time desc
limit
  20
```

本质是只是一个表的查询，不涉及多表联合查询。只是在单表查询，

- 列出的问题
  - ![image-20220606144554480](%E5%AE%9E%E4%B9%A0.assets/image-20220606144554480.png)

- 自己explain的执行结果【估计是已经进行了性能优化】
  - ![image-20220606143935383](%E5%AE%9E%E4%B9%A0.assets/image-20220606143935383.png)

-  查询类型也表明：simple简单的select查询。不涉及子查询或者联合查询

- 查询困难程度：ref。

-  涉及到的索引：index_status_time (`order_status`,`create_time`)
- rows：物理查询的行数。6w+，经过索引优化后，rows=1表明索引失效，或者说粒度不够
- key_len=4，命中索引的长度为4



**梳理**：

order_status 为int类型，不涉及类型转换

符合最佳左前缀原则，不涉及！=或者大于小于，范围查询，函数计算的情况。

而且extra：为using where 表明 create_time这个排序应该是生效了。

**解决办法：**

索引应该是没失效的。所以，可以在该索引基础上再添加新的字段 valid

第一个字段，order_status 整个列只有4个变量，所以以该字段建立索引，粒度不足。

![image-20220606153439031](%E5%AE%9E%E4%B9%A0.assets/image-20220606153439031.png)

建立索引

```sql
ALTER TABLE  yx_order  ADD INDEX index_valid_status_cutime ( `order_status`,`create_time`,`valid`,`update_time`)
```

将四个字段都建立索引，注意字段顺序。将范围查询的字段放在最后。status个数4，create_time多个，valid 4个，update_time 多个。update_time 范围查询虽然后续的字段会失效，但它是最后一个索引，索引失效也仍起到作用。而且前两个字段是对原来字段的覆盖，并不影响之前SQL语句的查询。

1. 建立索引，需要考虑，不能因为建立了新的索引，则更改原来的SQL语句。这是没有必要的
2. 创建联合索引，一般不删除原来的索引，避免因为索引删除，导致已经存在的SQL语句查询变慢。也可以将原来的索引覆盖掉，比如说当前例子【将新的的索引覆盖原来的索引，前两个字段没变，后面添加了新的字段】 

主要的变化在extra上。进行了优化，测试数据集不明显，若是在400w的表数据中，效果会更加明显。

![image-20220606211952456](%E5%AE%9E%E4%B9%A0.assets/image-20220606211952456.png)

- Using index: 所有的请求列都在一个索引树中，无需访问实际的行记录。即索引下推
- Using index condition：确实命中了索引，但不是所有的列数据都在索引树上，还需要访问实际的行记录。 
  - 性能不如Using index好
- Using where说明，在索引的基础上，使用了where条件过滤。
- Using filesort： 最差劲，坚决不能出现





- ### 慢SQL原因

索引建立不合理

- status个数只有4种，粒度不合理。
- 在select查询中，有多个字段，而之前的索引只有两个字段status,create_time的联合索引，是不合适的。应该是创建表后，增加了新的字段，旧的字段索引一直保留到现在。

- ### 最终的解决

![image-20220608201054497](%E5%AE%9E%E4%B9%A0.assets/image-20220608201054497.png)

```SQL
explain select
id,order_no,order_status,order_type,pay_mode,creator_id,creator_type,creator_name,customer_id,group_head_id,group_head_poi_id,receiver_name,receiver_contact_phone,receiver_province_id,receiver_city_id,receiver_district_id,receiver_province_name,receiver_city_name,receiver_district_name,receiver_address,cancel_operator_id,cancel_operator_type,cancel_operator_name,cancel_before_status,cancel_reason,total_price,create_time,update_time,valid,expected_delivery_time
from
  yx_order
where
  order_status = 50
  and update_time <= '2022-06-02 00:00:00'
  and valid = 1
order by
  create_time desc
limit
  20
```

使用了一个join连接

1. 首先使用非聚簇索引`index_valid_status_cutime`查找符合条件的id，此时由于我们构建的索引，保所所有的我们要查询的字段，所以，覆盖索引，直接返回结果。并没有回表查询。【extra，显示using index表示仅使用索引查询得出结果。即索引下推】
2. 连接查询，又因为连接查询返回id，则直接可以在聚簇索引查询。
3. 虽然后面出现了filesort，但是20行的排序，对性能影响不大 ，在结果对比中也能看到。使用原来的SQL，170ms左右，新的SQL，30ms左右。性能大幅提升



- **感想**
  - mysql中SQL优化，无论是从网上还是看书，学习各种技巧。但sql真正的优化，还需要从实操中验证。查询时间短才是真是效果好
  - 也就是说，mysql是黑箱操作。具体的优化，我们并不可知。所以我们在优化时，以实际查询的时间为准。





# 作战平台理解

CRM: Customer Relationship management,客户关系管理。在CRM中指维系C端(即商家，门店)的关系。在业务分块(一个完整的销售过程)中属于售前的部分。该模块存在的目的是为更好的发现商家(门店)，发掘和拜访门店，提高后续流程的成功概率，即销售成功率。一旦跨入售中流程，表示商谈成功，逻辑上不再属于CRM范畴。



作战平台：面向BD，而不是面向团长和顾客。

BD：商务拓展。

| 名词     | 解释                                                         |
| :------- | :----------------------------------------------------------- |
| BD       | 直营地推BD，进行商务拓展，将原本不是美团优选辐射的区域，推广成覆盖点 |
| 团点     | 官方名称：自提点                                             |
| 团长     | 自提点的主人，负责维护自提点的货物，                         |
| **团推** | 团长推荐商品次数                                             |
| 拓团     | BD拓团流程指从BD拜访到最终团长营业的过程                     |
| 商       | 商通过和美团合作，做美团的业务，靠做业务和美团分润来赚钱。   |
| 做功     | BD对团长做工作，可以是拜访，电话联系                         |
|          |                                                              |
|          |                                                              |
|          |                                                              |
|          |                                                              |
|          |                                                              |



- ### 作用：

  - 目标人群圈选——BD标签体系

  - 上传下达——作战计划、任务调度（老大做出计划，由程序对计划进行分割，分割成作战策略，作战策略再分割成任务。交给各个BD执行）

  - 过程管理——过程管理数据（显示任务进程，结果评判等信息，区分“过程完成”和“结果完成”）

  - 在平台（使用数据的）基础上，建立针对BD管理者、BD的评价体系

    管理者评价体系：

    - 管理效率/准确性
    - 业务团队产能方差

- ### 数据实体：

  - 销售平台主要的数据实体是：作战计划和作战策略，任务是调用任务系统。**计划由多个作战策略构成。**
    - 作战计划：
      - 不能为空，即内部有至少一条策略。
      - 包含**计划时间，计划状态**。 作废计划不能更改其状态
    - 作战策略  （会执行目标用户和优先级）
      -  时间周期，策略状态（与作战计划状态相同）。
      - 执行频次，一个策略可以多次执行。
        - 单次执行和每天执行
      - 通过标签找到目标用户和优先级【标签 查找是找交集】
  - **编辑实体**
    - 计划：更改状态和添加删除作战策略，**作战计划时间不能重合。**
    - 策略：工作量目标，达标量目标。，目标客户和优先级



- ### **标签** 【标签的作用是进行分类，我们通过标签获取指定的BD。BD系统交由数据组去做】

  - 具有相同特征的人群的描述，在作战平台里，主要用于人群圈选。例：希望对**近七日无拜访**的团长下发一个作战计划
  - 可以根据标签筛选在一定组织范围内筛选出符合条件的团队[作战对象]，团队可以指定到对应的执行人BD。

- 实现分层功能： 分层标签列表中展示当前操作者所在组织节点及下级组织节点的全部标签上传记录

  - **三种标签：团长画像类、CRM自建类、省区上传类标签**
    - 团长画像：对bd的多评价指标，并对其进行加标签。便于将作战计划分为多个作战策略时，作战策略必须指定至少一名BD。而任务执行可以通过标签进行分配。

- ### 通过作战策略生成任务。分给BD执行

  - 一个作战策略会根据标签选出团长，找到BD后，派发


系统全景图：

![image-20220602133337194](%E5%AE%9E%E4%B9%A0.assets/image-20220602133337194.png)





- ### ER图（关系对应图）

   ![image-20220601113825395](%E5%AE%9E%E4%B9%A0.assets/image-20220601113825395.png)

- ## 用例图 

  - ![image-20220606164352820](%E5%AE%9E%E4%B9%A0.assets/image-20220606164352820.png)
  - ![image-20220606164404662](%E5%AE%9E%E4%B9%A0.assets/image-20220606164404662.png)

- ### 目前业务流程

  CM层管理者将指定作战计划，再将计划分为多个策略，每个策略分为一个主任务和多个子任务。BD执行任务，任务方式有：电话联系，拜访等。根据执行情况会对BD进行评价，并将评价指标反馈给作战平台，作战平台的操作这CM组织人员可以进行微调。修改计划。并没有将系统做的很死板。相反，更具有灵活性。![image-20220601145934049](%E5%AE%9E%E4%B9%A0.assets/image-20220601145934049.png)

- ## 时序图


- 作战系统进行策略调度：策略调度最终目的是生成可以执行的任务，主要过程是在作战策略限定的时间范围内，按照指定的周期频率，通过标签系统筛选出一定规则的团长列表[作战对象]，同时获取相关的执行人、处理动作和目标结果，调用任务系统批量生成任务。
-   ![image-20220602133621590](%E5%AE%9E%E4%B9%A0.assets/image-20220602133621590.png)





- #### CM层级并不都擅长将目标拆解为策略

  - 是因为CM层级很多时候在私下拆解，并不是在线上的方式，而且可能与作战平台系统的方式也略有不同，所以出现了这个问题
  - 解决办法：由总部/大区/省区根据业务目标拟定落地策略，供CM直接挑选&执行

- 

- | 序号 | 系统平台     | 系统模块                                             | 子模块/系统能力                                              | 落地业务环节                                                 | 一期范围概述                                                 | 后续方向                                                     |
  | :--- | :----------- | :--------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
  |      | 作战平台     | **标签模块**                                         | 目标客户圈选                                                 | 制定计划                                                     | 标签业务控制层标签接入层省区自定义分层拜访标签               | 指标扩展性增强，同步解决fact大表问题销售过程标签领域能力的收敛 |
  |      | 目标模块     | 结果指标设定                                         | -                                                            | BD维度结果指标实时追踪                                       |                                                              |                                                              |
  |      | **作战计划** | 制定作战计划                                         | 引用标签模块引用策略调度控制能力                             | 引用目标模块支持从经营数据看板调用，制定指标改进计划         |                                                              |                                                              |
  |      | 任务调度     | BD执行                                               | 根据作战计划生成/回收任务                                    | 任务周期的扩展（一期支持1天1次、一次性任务）                 |                                                              |                                                              |
  |      | 任务存储     | 主任务工作包子任务                                   | 任务三重概念的解耦、持久化，以便过程管控模块快速调用         | --                                                           |                                                              |                                                              |
  |      | 任务控制器   | 触达方式定义                                         | 拜访电话触达                                                 | 支持更细颗粒度的拜访触达方式，例如电话触达精细化数据采集和使用抽象动作模型，串联拜访、电话、拓新、反馈等动作，与作战平台关联打通 |                                                              |                                                              |
  |      | 完成方式定义 | 团推动作团推成单小助手安装团长维度结果指标实时追踪   | 任务状态跟踪通用能力建设                                     |                                                              |                                                              |                                                              |
  |      | 工作量定义   | “过程完成”工作量定义及追踪“结果完成”工作量定义及追踪 | 支持指标型任务判定，可能超出布尔值范围                       |                                                              |                                                              |                                                              |
  |      | **过程管控** | 提供任务进度                                         | 管理者check&改进                                             | 根据子任务做聚合计算，支持管理者查看任务进度                 | -                                                            |                                                              |
  |      | 联动管理闭环 | -                                                    | 联动陪访联动团长明细数据查看联动指标型改进任务BD榜单BD与管理者评价体系建设 |                                                              |                                                              |                                                              |
  |      |              | 策略中心                                             | 策略模板                                                     | 总部/大区/省区管理维护                                       | 管理者创建策略模板     <br />管理者修改策略模板<br />管理者作废策略模板<br />管理者查看模板使用及活跃数据<br />管理者设置模板可修改字段<br />管理者配置模板目标组织用户 |                                                              |





# 作战平台 审批流

- 地方制定作战计划提出后，会先交由总部审批，审批通过后，在分为各个策略等信息
- ![image-20220602150146722](%E5%AE%9E%E4%B9%A0.assets/image-20220602150146722.png)

目的：**地方制定计划→总部审批→修订&审批完成后任务下发，因此需要建立可配置的审批流能力。**

表的对应关系

![image-20220607154639410](%E5%AE%9E%E4%B9%A0.assets/image-20220607154639410.png)

- ## 实现猜想

  - 仍然是对原来的原来的作战计划和作战策略表进行操作。
  - 在作战计划上添加新的字段，是否审批【0-不审批，1-审批】。由于作战计划与作战策略的状态相同。所以需要在在作战策略上增加一个新得字段
  - 审批字段。审批字段为0,1,2,3，4,5,6    对应：该策略：待审批，审批未通过，审批通过，审批中（审批状态>=3，表示审批中，可以是多级审批）【不可以，应为审批可能是多级审批，不能仅用一个审批中表示，所以可以改变字段对应关系，即上序表示】
    - **作战计划的（策略们）状态展示：**
      - 审批流中，“待审批作战策略数/总作战策略数”。每个作战策略的状态并不相同。所以需要添加新字段。【新增字段，则之前已有的数据，全部设置为0，不审批】
    - **状态的改变**
      - 提交者可以改变，在提交后，提交者可以修改作战策略的详细信息，无论是保存计划，还是保存并提交审批，都会将作战策略更改为待审批，而且撤回已经申请的审批
  

- 接口方面
  - 作战计划
    - 通过作战计划，查询所有的作战策略的状态数量，在VO中添加新的属性，各个状态的数量，待审批 【保存的文件但是没有提交】，审批中，执行中
    - 提交者可以更改作战策略的详细信息，在保存后，将该作战策略的状态改为待审批。若是保存并提交，则将该作战策略改为审批中3。将原本的作战策略信息进行覆盖。【所有的作战策略，无论是重新编辑还是首次新增都改为添加新的作战策略。若是更改，则将原来的作战策略改为 逻辑删除】
  - 审批中心
    - 可以查询所有的`策略ID、策略名称、时间周期、对应组织、目标客户及优先级、任务一级类型、任务二级类型、涉及团长数量（人均）、工作量目标、达标量目标`,只给该用户访问权限。
    - 审批人方面，可以使用多级审批，在获取审批状态时，只要是审批状态>=3，均是审批中。
    - 审批时，需要解决并发问题，若当前人正在审批该作战策略，而该作战策略已经撤回，改为待审批，所以在更改状态时，首先判断是够是逻辑删除，若是逻辑删除，则不能更改状态，抛出异常。或者返回“当前策略已撤回”。而且重定向到当前页面



# 作战平台1.0代码理解

作战平台1.0

![image-20220520104352575](%E5%AE%9E%E4%B9%A0.assets/image-20220520104352575.png)



-  crm-battle-client     ->接口，代码规范
- crm-battle-common   ->公共部分，导包等信息
- crm-battle-core    ->   
-  crm-battle-server    ->作战平台的具体实现--真正的SpringBoot
   -  ![image-20220530142440279](%E5%AE%9E%E4%B9%A0.assets/image-20220530142440279.png)
   -  只有config配置文件夹和thrift调用文件夹
   -  thrift可以理解为service层。为其他微服务调用或者网络接口调用。














# 问题

## 5.18问题

- 下载了代码，但会有各种包导不进去。权限问题？..

## 5.19问题

- MySQL中分库分表后怎么查询，不同数据源呢，怎么查询数据呢

## 5.24问题

- broker与分区的关系，一个分区与Follower的关系，一个分区应该是一个broker叭，那follower呢，也是一个全新的broker吗？还是分区的broker，也保存了其他broker的数据作为其他broker的follower
  - 分区与副本的关系
    -  kafka 服务器只有 4 个节点，那么设置 kafka 的分区数大于服务器台数，在 kafka底层如何分配存储副本呢？
  - 一个broker可以是多个分区的Leader？，那这样做，分区不就变得没意义了吗？
- 消息队列的数据是有过期时间的吧，那怎么处理一直没被消费的数据？我看到作战平台每天都有通知，有一个消息未被消费
- offset干嘛用的？

## 5-25问题

- socket请求，监听接收，数据读取，数据写入，不是一个东西吗？IO多路复用，单独一个线程，监听所有请求

## 5-26问题

- Redis应用:
  - redis解决分布式的session问题，
  - 分布式锁
  - （并发度高的请求）秒杀，
  - Redis底层数据结构
  - 内存淘汰策略
  - Redis作为缓存，策略
  - Redis集群
- MDP还是不能用，我真的服了。

## 5-27问题

- thrift使用：thrift的调用时service层的调用，不经过controller层。

## 5-30问题

- 看到需求创建规范 ，**feature/{需求issueId}/{简要描述}** 。需要有需求id才行。我目前需求应该轮不到我，那我是怎么使用分支吗？使用自己的分支吗
- Maven中，为什么不直接调用server而是使用client？
  - 因为一个大项目是多个团队合作开发。需求也是分发给多个团队。而且需求直接可能相互调用。若是一个团队等待其他团队开发完才开发影响开发效率。所以先构建出client标准（需求规范，与java中的接口类似），不影响其他其他人的调用开发。
  - 此外，降低了耦合，更加规范化。

## 6-1问题

网址 ： https://km.sankuai.com/page/980189501   



- 销售，地推人员，是推广优选服务是吗？，为其他团长服务？还是卖东西，

  - 进行商务拓展，选出附近有潜力的团长，并维护团长关系

- 直营地推BD是什么？ 是帮助团长操作软件的是吗，CM组织是什么，以省区为单位的BD组织吗？

  - CM组织是为了将BD各层管理人员。对作战策略和计划的操作人员

- 作战计划和作战策略是谁指定的？

- 策略编辑：电话触达，是什么意思？指定给哪个用户打电话？

- 标签是用来分层的叭，标签与作战计划的关系？

  - https://km.sankuai.com/page/1124794639
  - 现阶段，团长侧存在一个团长画像服务，但是其画像偏向于团效方面，目前缺少拜访维度的标签、不支持自定义设置标签这些能力，与销售侧需要的能力有一些差距。故销售侧需要构建一套自己的标签服务，面向的对象包括但不限于团长（可能会拓展BD，AOI等对象的标签），支持拓团、团效和团运营等多个维度的标签建立，支持销运/CM自定义标签人群，支持不同维度的标签数据快速接入。
  - 所以，标签的创建是我们要做的是吗
  - 三种标签：团长画像类、CRM自建类、省区上传类标签新建、编辑？
  - ![image-20220601113019582](%E5%AE%9E%E4%B9%A0.assets/image-20220601113019582.png)

- 任务不是交给其他组来做吗？咱们仅仅是调度是吗？

  - 是的，但任务系统也是我们销售小组的人来做，张凯凯

- 这个标签系统是已经存在的吗？还是说在作战平台内。我们自己创建？

  - 有一个标签系统，包括团长自画像，自定义标签和省区上传类标签

- 团推什么意思？团长有团长推送商品动作

- https://km.sankuai.com/page/1225977154  

  - CM层级不太擅长将目标拆解为策略，主动制定策略意愿不强

- ### 2.1.3 需求应用场景

  - BD执行任务时，系统将使用实时数据判定BD做功是否达标？做功是什么意思？

## 6-6问题

- https://km.sankuai.com/page/1124794639   技术方案一
  - 一个作战策略会根据标签筛选出团长、找到farmerBD后，派发任务，会生成一个主任务，一个主任务会对应多个子任务。咱们的目标人群不是BD吗？但是标签选出的是团长？
    - 作战平台不止是商务拓展，发展成团长后，会需要维护关系，这个过程也需要作战平台。



- 执行频次。一个策略可以多次执行？  

  - 是的，有的作战策略是每日的，也就是说会每日有新的策略，任务等

- 策略里面有工作量日标和达标量日标。有什么不同吗？

  - 是有不同的，BD的工作量日标表明该BD的当日工作量，而达标量日标为是否完成工作目标。将两个概念区分开是为了，可能出现任务是团长主动去做的，BD没有实际的工作输出。

- https://km.sankuai.com/page/1219321825

  - 4.2   标签系统数据流转图 不懂？，后面的任务系统也不太懂

- https://km.sankuai.com/page/1219321825#id-4.4%E3%80%81ER%E5%9B%BE

  - 技术方案在行成时，要在开发完成之前完成吗？还是说在边开发，边完善这个技术方案。   
    - 技术方案是先写技术方案，再开发。
  - 里面我看到有表的信息，是咱们来创建吗？  
    - 是我们自己创建

- 请研发同学在设计V3.0版本时，尽量为这些后续扩展留好可行性？

  - 这应该怎么考虑呢？

- 作战目标是什么？  

  - 将作战目标，指定成作战计划，再将计划分为多个策略

- 解决当前最优先的作战平台易用性问题及场景需求？ 易用性不是一个优点吗？    应该是文字编辑错误，是为了易用性。

mysql

- 两个查询时间，具体以哪个时间为准？  测试环境均
- https://km.sankuai.com/page/1146214044    第一个优化哪了？     删除了一个where条件 id>0 ，实际上，id自增，均大于0

## 6-7问题

- 上面显示在执行中，已作废。但我在作战策略上没有看到状态字段。是作战计划的状态字段吗？
- 审批文件是提交给谁？他们怎么审批呢，是一个新的审批系统吗？在测试系统中看到这个审批中心。兜底审批人？
  - 有一个新的审批系统

- 只能提交新的计划吗，不能指定旧的计划，在旧的计划中添加新的策略吗？
- 将根据用户权限来判定是否有该策略的审批权限。审批中心也是咱们来开发吗？，还是只显示申请来的作战策略即可。.
- 待审批有歧义？是保存文件，但是没提交是待审批，若是提交了，但是审批的工作人员一直没开始审批，怎么说，也是待审批吗？还是审批中。
  - 保存作战策略是待审批，若是保存并提交，则改为审批中状态，

- 审批过程应该是一个单独的系统吧，审批不能仅仅是审批通过不通过吧，应该也可以有备注通知这些东西吧，是需要在作战策略上添加新的字段吗



























































































# 学习计划

Spring    3天

thrift     4天

kafka/mafka  2天    

es+git        2天

OCTO 服务治理         

cat 日志上报   （后置，要求不高）

Mttrace 分布式链路追踪   （后置，要求不高）

MySQL+MyBatis   2天

Redis    2天





1、spring/mtthrift/kafka/es 会用，基本原理       

2、cat/mttrace/databus/rhino 了解 

​			databus：监听数据文件，

​			rhino：限流， 

3、mybatis/redis/mysql







