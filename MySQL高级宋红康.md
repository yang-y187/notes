# 4，逻辑架构

## 1.1 逻辑架构

![image-20220315144637570](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315144637570.png)

- 连接层：客户端访问服务器之前，做的第一件事就是建立TCP连接，并检测账号密码是否正确，之后再连接池中给该客户端分配一个连接；
- 服务层：服务层的主要作用是提供和SQL交互的接口，解析并检查SQL是否语法正确，优化分析，并且使用缓存。
  - 缓存组件：查询到来时先到缓存中进行查找，没有的话去表中查找，并将结构保存在缓存中，**缓存可在不同的客户端之间共享**。mysql8.0删除了缓存
  - 解析器：会将传入的sql解析，检查语法是否正确，同时会检查该用户是否有对应的权限
  - 优化器：优化器会根据所创建的索引，对sql进行优化
- 存储引擎层：MySQL的存储引擎是插件式的，他真正的负责了对mysql中数据的存储和提取，对物理磁盘上的数据进行操作。不同的存储引擎具有不同的功能
- 存储层：所有的数据都（表结构，用户信息，每一行内容，索引等）都是以文件系统的方式存储在物理磁盘上的。

## 1.2 SQL执行流程

5.7：SQL执行流程

![Image](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/Image.png)



1. ![image-20220315145246261](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315145246261.png)

1. 查询缓存：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。

**大多数情况查询缓存就是个鸡肋，为什么呢？**

![image-20220315150018720](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315150018720.png)

2. **解析器**：对SQL语句进行语法分析，语义解析

   词法分析：识别字符串中各个位置的含义，即关键字

   语义解析：或者说语法分析，判断当前输入的SQL语句是否符合MYSQL语法

3. **优化器：**

   SQL查询需要使用对当前SQL语句进行优化，生成最优的方案。

4. **执行器：**

   首先判断用户是否有权限，如果没有，则权限错误。否则执行SQL。

![image-20220315151725876](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315151725876.png)

# 5，搜索引擎

## 5.1简介

- 搜索引擎负责对表的数据进行读取和写入工作**。我们将不同的表设置不同的引擎**，一个库可以使用不同引擎，换句话说，**一个表使用一个引擎。**
- 再mysql5.5之后，InnoDB就是默认的存储引擎。

## 5.2 InnoDB引擎

==InnoDB引擎 具备外键支持功能的事务存储引擎==

- MySQL 5.5版本之后，默认采用InnoDB引擎
- **支持外键，行级锁**
- InnoDB引擎是事务存储引擎，可以处理事务，所以可以确保事务的完整提交和回滚。
- **数据库异常崩溃后可安全恢复**
- InnoDB是 为**处理巨大数据量的最大性能设计** 。换句话说，如果是处理小表的话MyISAM效果更好。
- **对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和索引。（因为索引的问题，所以在写处理方面略差）**
- **MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较高 ，而且内存大小对性能有决定性的影响。（索引方式不同）**
- InnoDB存储引擎的底层的文件结构：
  - 以.frm为后缀的文件存储表结构   
  - 以.ibd为后缀的表存储数据和索引

## 5.3 MyISAM引擎

- 5.5之前默认的存储引擎
- MyISAM 不支持事务、行级锁、外键 ，有一个毫无疑问的缺陷就是 **崩溃后无法安全恢复** 
- 只缓存索引，不缓存真实数据
- 优势是访问的 **速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用**
- 应用场景：**适用于读和插入操作较多的情况选择MyISAM**
- 底层存储的文件结构：
  - 以.frm结尾的后缀存储表结构
  - 以.MYD结尾的后缀存储数据
  - 以.MYI结尾的后缀存储索引





==**InnoDB引擎与MyISAM引擎的区别：**==

首先对于InnoDB存储引擎，提供了良好的事务管理，**崩溃修复能力**和并发控制。因为InnoDB存储引擎支持事务，所以对于要求事务完整性的场合选择InnoDB，比如数据操作除了插入和查询，还有更新和

![image-20220315155302203](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315155302203.png)

- **InnoDB数据库异常崩溃后可安全恢复**
- InnoDB是 为**处理巨大数据量的最大性能设计** 。换句话说，如果是处理小表的话MyISAM效果更好。
- **对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和索引。（因为索引的问题，所以在写处理方面略差）**
- **MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较高 ，而且内存大小对性能有决定性的影响。（索引方式不同）**

# 6，索引的数据结构

## 1，索引

**索引（Index）是帮助MySQL高效获取数据的数据结构**

索引的本质：排好序的快速查找数据结构

优点：

- 降低数据库的IO操作，节省时间
- 创建唯一性索引，来保证数据库的表中每一行数据的唯一性
- 在实现数据的参考完整性方面，可以 加速表和表之间的连接 。
- 减少查询中分组和排序的时间 ，降低了CPU的消耗。

缺点：

- 建立和维护索引需要时间
- 索引需要空间存储
- 索引值提高了查询速度，同时降低了更新表的速度，对表数据的修改也需要更改索引，其他操作时间降低。

## 2，InnoDB中索引

**一般情况下，我们 用到的B+树都不会超过4层，因为层数越少，IO次数越少，这样查询的时间就越少。**



InnoDB中，索引按不同的物理方式可以分为**聚簇索引**和**非聚簇索引**（二级索引，辅助索引）

![image-20220315172115714](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315172115714.png)

- ### **聚簇索引**

  - 特点   （页即非叶子节点）
    - 页内的记录存储页号和主键， 叶子节点 存储的是完整的用户记录
    - 同一层级的页使用双向链表，不同层级的页使用单向链表
  - 优点：
    - 数据访问更快，从聚簇索引中获取数据比非聚簇索引更快。
    - 适用于**排序查找**和**范围查找**
  - 缺点：
    - 插入速度严重依赖于插入顺序，更新主键的代价很高

**MySQL中，只有InnoDB引擎支持聚簇索引，而且默认创建，MyISAM并不支持**

**每个表只能有一个聚簇索引，MySQL会使用主键自动构建索引**

如果表没有定义主键，InnoDB会选择非空的唯一索引代替，如果没有，MySQL则会隐性的构建一个

- ### 非聚簇索引

  （若搜索条件是主键查找，则使用聚簇索引，**若是其他条件查找，则需要使用非聚簇索引，本质是构建多颗B+树，以表另外一字段列作为索引，不使用id。但是叶子节点数据是id。在查找到id后，再从聚簇索引中查询完整的用户信息**）

![image-20220315174328669](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315174328669.png)

为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？

答：叶子节点也保存数据会造成空间的浪费（因为保存了多份相同的数据，而且索引未必是唯一的）。而且以其他条件作为索引，可能不是非空，唯一。

- 联合索引

  **（本质也是非聚簇索引，选择了多个列作为索引）**
  
  - 联合索引指的是：选择C1，C2多个列作为索引，构建一颗B+树。
  - 先把各个记录和页按照c1列进行排序，若C1相同，则再按C2排列。叶子阶段也是包含主键数据

###  InnoDB的B+树索引的注意事项

1. 根页面位置万年不动
2. 内节点（页目录）中目录项记录的唯一性，
   非聚簇索引构建B+树，也会保存主键的值，为的是避免出现页目录中，有两项完全相等的情况
3. 一个页面最少存储2条记录

## 3，MyISAM中的索引

MyISAM引擎使用B+树作为索引结构，叶子节点的data域存放的是**数据记录的地址**

- MyISAM原理
  - 使用的都是非聚簇索引，因为索引和数据是分离的，叶子节点存储的是数据地址。

![image-20220315181129955](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315181129955.png)



Myisam索引和InnoDB索引的对比

- MyISAM索引方式是非聚簇索引，InnoDB包含一个聚簇索引
- MyISAM引擎每次查找都需要回表
- InnoDB数数据文件本身就是索引文件，而MYISAM索引文件与数据文件是分离的，索引文件保存数据的地址
- InnoDB中，非聚簇索引的叶子节点的data域保存的是数据主键，而MYISAM保存的是数据地址。可以直接读取数据，InnoDB需要两次查找操作，在时间上，MyISAM更快。

## 4， 索引的代价

![image-20220315182423986](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315182423986.png)

## 5，B树与B+树，Hash索引，AVL索引

**这一章节为MySQL数据结构选择的合理性，目的是减少磁盘的IO次数**

![image-20220315183201525](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315183201525.png)

- 特点：

  - 叶子节点和非叶子节点都存放数据，搜索可能到不了叶子节点就结束
  - B树在插入和删除结点的时候导致树不平衡，则通过自动调整叶子节点的位置保持平衡
  - 搜索性能等价于二分查找

  **B+ 树和 B 树的差异：**

- B+ 树中，非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非叶子节点既保存索引，也保存数据记录 。

- B+树的查找效率更高，而且更加稳定，因为都需要多次索引才会读取到数据，而B数可能在非叶子节点就读取到数据，虽然说这样看似效率更高，但是非叶子节点存放 数据，势必存放的索引减少，非叶子节点增多，增加IO，查找效率就降下来了。

- **B+树同级之间存储双向链表。**



**Hash索引结构**   **只有Memory存储引擎中使用**

hash查询速度很快，但是有缺点

- **hash索引在等值判断的情况下是速度很快的**。如果进行范围查询，则退化为全表查询
- 范围查询，分组查询失效，退化为全表查询
- 无法进行联合查询。因为不同的字段结合在一起，无法判断
- 若数据值重复太多，非常多的哈希碰撞。非常耗时



二叉搜索树

开始选择二叉搜索树，可是二叉搜索树容易出现斜树。IO数量很多，所以选择平衡二叉搜索树

**AVL树**  平衡二叉搜索树

- 依然很多IO操作，可以将二叉树改为M叉树--->B 树

# 7，InnoDB数据存储结构

## 1. 数据库的存储结构：页

![image-20220315185808358](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220315185808358.png)

- InnoDB 将数据划分为若干个页，InnoDB中页的大小默认为 16KB 。
- **数据库管理存储空间的基本单位是页**
- 各个页之间可以不在物理结构上相连，靠双向链表连接。
- 页内部的数据通过单向链表连接，每个数据页都会存储一个页目录，可以通过二分法进行查找

# 8，索引的创建与设计原则

## 1，索引的声明与使用

### 1，分类：

- 逻辑功能角度：普通索引，唯一索引，主键索引和全文索引
- 物理实现角度：聚簇索引和非聚簇索引
- 字段个数角度：单列索引和联合索引

### 2，创建

**创建表时，在声明有主键约束，唯一性约束，外键约束的字段上，会自动创建相关索引**

- 创建表时：

```sql
CREATE TABLE table_name [col_name data_type] [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]
```

- 表已经存在，添加索引

```SQL
ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]
[index_name] (col_name[length],...) [ASC | DESC]
```

或者

```SQL
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (col_name[length],...) [ASC | DESC]
```

-  删除索引

```SQL
ALTER TABLE table_name DROP INDEX index_name;
```

或者

```SQL
DROP INDEX index_name ON table_name;
```

##  2，索引的设计原则

1. 字段的数值有唯一性的限制，可以设置为索引
2. GROUP BY 和 ORDER BY 的列
3. 经常作为，增，查，改操作的WHERE 查询条件
4. 经常去重字段需要创建索引
5. 在条件允许的情况下，可以使用联合索引，优先将筛选力度大的放在左侧。**联合索引优于单值索引**
6. 多表join连接操作时，创建索引注意事项：
   1. 连接表的数量不要超过3张
   2. 对where条件创建索引
   3. 对用于连接的字段创建索引
7. 使用列的类型小的创建索引（即对UUID建立索引，没必要）（比如说：varchar（50）varchar（20），选择小的那个，在大的在页中存储的少，则增加IO）
8. 使用字符串前缀创建索引

**限制索引数目**



## 3，不适合创建索引的情况

- where使用不到的字段，不使用索引
- 数据量小的表最好不要使用索引
- 有大量重复数据的列上不要建立索引（**区分度不够的列不要创建索引**）
- 经常更新或者修改的表不创建索引



## MySQL性能分析

- 观察服务器状态
- 开启缓存，查看缓存
- 开启慢查询
  - SQL等待时间过长 通过指令 show profiles
    - 调优服务器参数（加内存，刷盘策略）
  - SQL执行时间过长   通过指令 Explain
    - 进行索引优化
    - 表结构的优化
- 开启主从复制

## 4，性能分析EXPLAIN

Explain：使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈 

用处：

![Image](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/Image-16473476022741.png)

Explain + SQL语句：

属性： 

- **id：** **select查询顺序，表示查询中执行select子句或操作表的顺序**
  - id不同：若是子查询，id序号会递增。id越大，优先级越高。越先被执行 
  - id相同：执行顺序，由上到下。     
  - id同与不同，同时存在

  关注点：    

 **id号每个号码，表示一趟独立的查询。一个sql 的查询趟数越少越好。即只有id=1为最好**

- **select_type：**查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询

![Image](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/Image-16473477832302.png)

- **type：表示查询使用了哪种类型。即查询困难程度（优化指标）**

  从最好到最差依次是：

  ​	system>const>eq_ref>ref>range>index>ALL

![Image](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/Image-16473478402643.png)

- possible_keys：查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

- **keys：**  实际使用的索引。   查询中若使用了覆盖索引，则该索引和查询的select字段重叠

- **key_len:** where后面的筛选条件命中索引的长度，与order by 和group by无关。应用索引的长度。数值为索引中使用的字节数，**越大越好**

  key_len字段能够帮你检查是否充分的利用上了索引

- **rows：**rows列显示MySQL认为它执行查询时必须检查的行数。**（越小越好）**

- Extra：包含不适合在其他列中显示但十分重要的额外信息

![Image](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/Image-16473480437764.png)

Using filesort：没有应用到索引进行排序，很慢。  

Using temporary： 应用到order by 或者 group by。很慢很慢 ，一般出现Using temporary，会连带着出现

Using filesortUsing join buffer：join 连接条件key未使用索引，很慢

impossible where：where 条件逻辑错误。

## 5，索引失效的情况

- 不满足**最佳左前缀原则**，没有按照联合索引的顺序查询，或者说缺少左侧列的条件查询
  索引文件具有 B+-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。
- **索引列使用函数或者计算**（计算、函数、(自动or手动)类型转换）会导致索引失效
- 联合查询，范围查询后的索引列无效。（**构建联合索引时，将经常范围查询的列（字段）放在最后**）
- 字符类型转换也会索引失效
- **mysql使用不等于**（`！=`或者 `< >`），索引失效
- is null可以使用索引，is not null 不能使用 。 **不等于当然是失效的**
- **like以通配符开头('%abc...') mysql索引失效**  



## 6，关联查询的优化总结（join）

关联两个表的关联分为**驱动表**和**被驱动表**。驱动表作为主表，被驱动表是从表。

**关联查询就是嵌套查询，会首先遍历驱动表，中选择符合的数据，在从被驱动表中进行匹配。所以是小表驱动大表。一般大表会建立索引，这样能够使得速度更快**

- **永远用小结果集驱动大结果集（本质减少外层循环的数据量）**
- 保证被驱动表的JOIN字段，已经建立索引
- 内连接，MySQL会自动选择小结果集作为驱动表
- 子查询尽量不要放在被驱动表，有可能使用不到索引。
- 能够直接多表关联的尽量直接关联，不用子查询。



8.0使用Hash join

**STRAIGHT_JOIN：1，指定驱动表和被驱动表 2，明确前后两表的数量级**

STRAIGHT_JOIN=> inner join  

STRAIGHT_JOIN前面为驱动表，后面为被驱动表。

适用于 MySQL优化器选择的驱动表不好情况下，要替换驱动表



## ==**SHOW PROFILE**==

**查看查询成本。**

```sql
show profiles;
```

show profile的常用查询参数：
① ALL：显示所有的开销信息。 

② BLOCK IO：显示块IO开销。 

③ CONTEXT SWITCHES：上下文切换开
销。 

④ CPU：显示CPU开销信息。 

⑤ IPC：显示发送和接收开销信息。 

⑥ MEMORY：显示内存开销信
息。 

⑦ PAGE FAULTS：显示页面错误开销信息。 

⑧ SOURCE：显示和Source_function，Source_file，Source_line相关的开销信息。 

⑨ SWAPS：显示交换次数开销信息







## 7，子查询优化

- 可以使用连接（JOIN）查询来替代子查询
- **不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代**



## 8，排序优化

**问题：**在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？

SQL中，在where 和order使用索引，where是避免全表扫描，order by使用索引是为了避免FileSort排序。

**FileSort排序：**一般在内存中排序，占用CPU过多，如果结果较大，会产生临时文件，增加IO，**效率较低**

所以：索引尽量使用 Index 完成 ORDER BY 排序。

order by  

- **无过滤，不索引。**   
  - 即没有limit条件，无法应用索引。

- **顺序错，必排序。**   
  - 即建立索引的顺序与order 条件的顺序不同，出现 Using filesort 

- **方向反，必排序**  
  - 即order排序多个属性，若asc和desc都存在，则出现 Using filesort 

### filesort算法：

双路排序和单路排序

- 双路排序（进行两次磁盘扫描，**慢**） MySQL 4.1之前使用
  - 首先读取order by的字段进行排序
  - 在根据排序后的结果集，读取磁盘完整的数据。
- 单路排序（一次磁盘扫描）
  - 在磁盘中读取需要的列数据，选择其中字段order by排序

由于单路是后出的，总体而言好过双路

**group by的原则与order by相同，唯一不同是没有过滤条件，也可以直接使用索引**

## 9，覆盖索引

- 一个索引包含了满足查询结果的数据就叫做覆盖索引。
- **非聚簇索引的叶子节点，会保存数据的索引字段和主键。若select查询列仅为这些数据，则不必回表。**（即建索引的字段正好是覆盖查询条件中所涉及的字段）。

优缺点：

- 避免了InnoDB的二次查询，（回表）
- 可以把随机IO变成顺序IO加快查询效率
- 索引字段的维护 总是有代价的。(缺点)

## 10，索引下推（ICP）

MySQL5.6中的新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。



**实例：**

```SQL
# index name_age (age,name);创建联合索引
```



```SQL
select * from user where name like'%A' and age = 10; #（100条数据回表）
```

由于name是模糊查询,按理来说是失效的。只会使用age=10这个索引条件，再回表进行模糊查询。索引下推（ICP）会实现。在二级索引中的name字段进行模糊查询，将结果再进行回表。提高了查找速度。

**ICP的使用条件：**

-  只能用于二级索引(secondary index),减少基表（聚簇索引构建的表）的查询次数
- 只有二级索引字段为筛选字段才能起作用。即二级索引中有该字段才可以使用ICP

![image-20220317142452379](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220317142452379.png)

# 13 ，事务

## ACID

![image-20220318084152469](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220318084152469.png)

![image-20220320131251067](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220320131251067.png)

## 数据并发问题

![image-20220318084331182](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220318084331182.png)

## 事务隔离级别

![image-20220318085347144](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220318085347144.png)



# 14，MySQL事务日志

而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。

- **REDO LOG 称为 重做日志** ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。
- **UNDO LOG 称为 回滚日志** ，回滚行记录到某个特定版本，用来保证事务的**原子性和一致性**



- 事务的状态：
  - 活跃的：一个正在执行的事务
  - 部分提交的：指的是也执行完最后一条语句，在内存中修改但未刷新到磁盘
  - 失败的：指的是处于活跃或者部分提交状态的事务出现了意外
  - 终止：失败的事务回滚到初始状态
  - 提交：部分提交的事务刷新到磁盘中。

## 1，REDO日志

- 在处理数据库数据时，构建缓冲池，总是先修改内存中的数据。然后再更新到数据库。缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。
- 由于事务的持久性，修改内存和修改磁盘有时间间隔，也不会每次操作都修改磁盘，操作时间慢。所以使用了redo日志。
- redo日志记录事务处理的所有操作，并保存在磁盘中。内存每1s进行刷盘。若服务器宕机，则按redo日志记录操作进行持久化操作。

**好处：**

- redo日志降低了刷盘频率
- redo日志占用的空间非常小
  内容是存储表空间，页号，偏移量以及需要更新的值，所需的空间小，刷盘快

**特点：**

- redo日志是顺序写入磁盘的

- **事务执行过程中，redo log不断记录**

  bin log是在事务提交后，在一次性的写入日志

redo 日志的组成：有内存和文件两部分组成，redo log buffer和redo log file；

**redo Log整体流程：**



![image-20220316162205045](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220316162205045.png)

1. 更新事务提交后，首先检查内存中是否有对应的数据，没有则在磁盘中读取
2. 加载到内存中后，对数据执行事务。执行事务的同时，写入redo log 缓冲中。
3. 执行完成后，将redo log缓冲中的内容写入redo log file。
4. 定期进行刷盘操作，将数据缓冲写入到磁盘
5. 若服务器宕机，则通过redo log file进行持久化操作



![image-20220316163354332](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220316163354332.png)

**redo log的刷盘策略：**

- redo log buffer刷盘到 redo log file的过程并不是真正刷到磁盘，而是写入到文件系统缓存（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定。

针对这种情况，InnoDB通过修改innodb_flush_log_at_trx_commit参数可以更改刷盘策略。即如何将 redo log buffer 中的日志刷新到 redo log file 中

- 设置为0 ：事务提交不刷盘，使用系统刷盘（**系统默认master thread每隔1s进行一次重做日志的同步**）
- 设置为1 ：每次事务提交就刷盘**（ 默认值 ）**
- 设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。



**redo log file写入策略：**

日志文件的大小是有限，因此可以采用循环使用的方式，当数据已满时，就会将一部分已经更新的文件清空。

## 2，undo 日志

undo日志是事务原子性的保证，即在事务中，执行失败，使用undo日志进行回滚，恢复到事务执行前的状态。

- 对记录做出改动，则会将回滚时需要的数据记录下来。（**增，删，改回记录日志，查不会记录**）
- undo日志也会产生redo log。因为回滚日志也需要持久化的保护

**作用：**

- 用于回滚，保证事务的一致性
- MVCC，MySQL中可以用于多版本并发控制

**undo log 重用**

因为操作多，undo log生成多。另外mysql操作单位是页，16K。undo log可以判断是否可以重用。小于3/4，可以重用。重用是在当前undo 页后面记录当前的数据



- uodo log的分类和删除：
  - insert操作：对于insert undo log来说，因为数据仅对当前事务可见，提交后可以直接删除
  - update操作：对于update undo log来说，当前版本中的数据在MVCC中可以会供其他读操作使用，因此不能删除



![image-20220316170417179](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220316170417179.png)

redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。

# 15，锁

## 1，**并发问题：**

读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。

- 方案一：读操作利用多版本并发控制（ MVCC ），写操作进行 加锁 。

- 方案二：读、写操作都采用 加锁 的方式。

采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 。
采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能。

- 锁的分类
  - 数据类型的类型：写锁（排他锁），读锁（共享锁）
  - 操作的粒度：表锁，行锁和页锁
  - 对其他锁的态度：共享锁和排他锁

## 共享锁，排他锁

- 共享锁  s锁 ：不会影响数据读取，可以多线程读
- 排他锁  x锁 ：只能有一个事务操作，防止其他用户的读写

需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。

注意：**读操作可以加s锁也可以加x锁，写操作只能加x锁**

需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。

## 表级锁，行锁

- LOCK TABLES t READ ：InnoDB存储引擎会对表 t 加表级别的 S锁 。
- LOCK TABLES t WRITE ：InnoDB存储引擎会对表 t 加表级别的 X锁 。

InnoDB可以使用行级锁，表锁，MyISAM只能使用表锁

- 表锁
  - 表级别的x，s锁：InnoDB一般使用行锁不使用表锁，	
    **使用场景：InnoDB在修改表结构的时候会加上表级锁**
    					MyISAM使用的只有表级的x，s锁
    - s锁：在加锁期间，所有人可读，所有人都不能写。加锁期间也不能操作（增删改查）其他表。只有解锁后才可以
    - x锁：在加锁期间，该用户可读，可写。其他人读写该表都不可。而不能操作其他表
  - **意向锁（表级别）** **行锁和表锁共存**
    - 使用场景：用户在表中某行加入了行锁，会在更加的一级空间（页锁或者表锁）添加意向锁，通知其他操作，已经上过意向锁。不必再遍历查询是否表中有锁。因此，实现了行锁和表锁的共存。
    - **添加行锁后，存储引擎自动添加意向锁**，用户无法操作。分为意向共享锁 IS和意向排他锁 IX
    - 意向锁与表级的xs锁是阻塞的，is和s不会。意向锁与意向锁之间都是兼容的
  - 元数据锁（MDL锁）：对表的结构做出变更时，会有MDL写锁。对表做增删查改时加MDL读锁。防止修改表数据时，表结构发生变化。
- InnoDB的行锁
  - 记录锁：与表锁特性相同
  - 间隙锁：只为了解决幻读问题，禁止该行所在间隙插入数据。共享和独占锁作用相同。
    - 比如数据为 1,5。插入间隙锁可以是2，3，4都可以加间隙锁。开区间
  -  临键锁：锁住该条记录以及该行与上一行的间隙
    - 记录锁和间隙锁的结合。左开有闭
  - 插入意向锁：由于间隙锁，其他事务在该间隙插入数据，会等待。等待期间会在内存中生成一个插入意向锁，表明要在该行插入数据的意向。

## 乐观锁，悲观锁

- 悲观锁
  - 每次操作数据都会上锁，行锁表锁都是悲观锁。
  - **适用场景：**适合写操作多的场景
- 乐观锁
  - 乐观锁是通过程序来实现
  - 每次操作不会上锁。通过版本号机制，时间戳机制（CAS）
  - **适用场景：**适合读操作多的场景

# 16，MVCC

## 1，简介：

通过对多个版本的管理来处理数据库的并发问题。在一个读事务读取的数据正在被其他事务操作时，可以读取该数据的旧版本。

**多版本并发控制** => MVCC。读写操作出现的事务问题（脏读，脏写，幻读，不可重复读），可以通过MVCC解决。

解决的隔离级别是读已提交和可重复读

## 2，快照读和当前读

**快照读：**读取数据，若数据正在被其他事务操作，则读取旧版本的数据。普通不加锁的读就是快照读

**当前读：**读取的数据一定是最新版本的数据。  **加锁和修改操作都是当前读，与MVCC无关**

## 3，MVCC实现原理

- MVCC的实现依赖于：**隐藏字段，Undo log，ReadView**
- **隐藏字段：**    **Undo log 对每一次的修改都会保存一下数据**
  
  - 聚簇索引中保存：操作当前数据的事务Id，和回滚指针（寻找undo log）
    - trx_id ：每次事务对数据进行改动时，聚簇索引都会把该事务的事务id赋值给trx_id 
    - roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。
- **undo log：**是MySQL读取以前版本的数据来源。
- MVCC使用**快照读**来解决并发问题。**解决的隔离级别是读已提交和可重复读**。ReadView中包含
  - 创建该ReadView的事务ID
  - 生成ReadView时其他未提交的事务ID列表或者说活跃的事务ID列表
  - 活跃事务的最小ID
  - 所有ReadView（包括现在活跃的和已提交的）的最大事务id，递增值

- MVCC版本控制的基本原则：

  （根据这个ReadView，判断哪个版本是可见的）

  - 若当前被访问版本的事务id与ReadView的事务ID相同，则当前版本可以访问
  - 若当前访问版本的事务ID小于ReadView活跃事务的最小ID，则当前版本可以访问
  - 若当前访问版本的事务ID大于所有ReadView最大事务ID，则不能访问
  - 当前访问版本的事务ID大于ReadView活跃事务的最小ID，小于所有ReadView最大事务ID。需要二次判断
    - 当前访问版本的事务ID是否在活跃的事务ID 列表（即是否已经提交）
    - 在列表，则不能访问，不在则可以访问



ReadView与每一个Undo Log的版本进行匹配。（遍历的事务Undo log中的各个版本）

## 4，MVCC整体操作流程

查询一条记录如何通过MVCC获取

1. 首先获取事务自己的ID
2. 获取ReadView
3. 若查询到数据然后与ReadView中的事务ID比较
4. 不符合规则，则从Undo log中获取历史版本，挨个遍历
5. 最后返回符合规则的数据

**MVCC只在这两个隔离级别起作用    --->可重复和不可重复读：**

- **不可重复读（读已提交）：**同一次事务，每次select都会产生一个ReadView，会生成不同活跃列表等信息。所以可能会读取到不同的数据
- **可重复读：**在事务开始的时候生成一个readview供全部的select使用，因此是可以重复读

# 17，常见日志

## 1，常见日志

- 通用查询日志：记录MySQL从启动到终止过程中的执行所有指令的日志
- **二进制日志：**记录所有更改数据的语句，用于主从复制，以及服务器遇到故障时的无损失恢复
- **中继日志：**主从复制中，从服务器存放二进制日志内容的一个中间件

## 2，二进制日志

binary log：它记录了数据库所有执行的DDL和DML等数据库内容进行修改的操作。

**binary log场景：**

- 数据恢复
- 数据复制

## 3，bin log和redo log对比

- redo log是物理日志，记录的内容是数据做出什么修改。输入InnoDB存储引擎产生的
- bin log是逻辑日志，记录内容是语句的原始逻辑 
- 虽然都是属于持久化的保证，但是侧重点不同
  - redo log 让InnoDB存储引擎拥有崩溃恢复的能力，持久化数据库的数据
  - bin log 保证了主从复制的数据一致性
- redo log 是执行事务时就写入数据，bin log日志是事务一提交才写入日志

## 4，两阶段提交

redo log 是执行事务后就写入数据，bin log日志是事务一提交才写入日志。若事务提交后，出现异常，导致redo log日志写入完成，bin log日志未写入。导致从机数据未更新。

所以选择两阶段提交：

redo log日志写入分为两个阶段，

- 若在写入 bin log日志出现异常，则redo log没有第二阶段，所以会进行回滚。
- 若relo log设置commit阶段发生异常，不会回滚。因为发现bin log日志已经写入，不必回滚

![image-20220317164607408](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220317164607408.png)

**binary log日志格式**

- Statement
  - 记录每一条修改数据库的SQL语句。**默认的bin log 格式**
  - 优点：
    - bin log日志较小，不必记录每一行数据的变化，
    - 主从版本可以不一样，从服务器版本可以比主服务器版本高
  - 缺点：
    - 

- Rows
  - 不记录指令，只记录数据库修改的内容



- MIXED模式
  - Statement和Row的结合，一般语句使用statment格式保存binlog。一些函数，使用row格式保存binlog。

## 中继日志

**中继日志只在主从服务器架构的从服务器上存在。**从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入 本地的日志文件 中，这个从服务器本地的日志文件就叫中继日志 。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的 数据同步 。

# 18，主从复制

主从复制是实现读写分离。读操作和写操作在不同服务器上。用户“读多写少”，所以分离操作，缓解数据库压力。

## 1，主从复制作用

- 提高数据库的吞吐量
- 读写分离

- 数据备份
- 具有高可用性

## 2，主从复制过程

**主从复制会生成3个线程来操作，一个主库线程，两个从库线程**

- 二进制日志线程：主机将数据库变更添加到bin log
- 从库I/O线程：读取主库的bin log日子，并写入到从机的中继日志  Relay log
- 从库SQL线程：读取中继日志内容并执行响应操作



![image-20220317165816847](MySQL%E9%AB%98%E7%BA%A7%E5%AE%8B%E7%BA%A2%E5%BA%B7.assets/image-20220317165816847.png)

**复制的最大问题：延时**

主从复制过程中，会有4次io的读写操作，势必慢

**原则：**  

- 每个从机只能有一个master（主机）  
- 每个slave只能有一个唯一的服务器ID  
- 每个master可以有多个slave，任意多台从机
