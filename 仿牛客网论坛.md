# 数据库信息

- **discuss_post**（帖子信息）：
  - usedId，标题，内容，评论数量，创建时间，热点评分（根据此来进行热点排序，与评论，点赞相关），
  - status（0：正常; 1-精华; 2-拉黑，帖子并未真正删除，而是改为不可见状态。）【精华是标题更显著】
  - type：0：普通帖子，1，指顶
    - 为什么把置顶与精华帖子分为两个字段？两个都是在说明帖子的状态？ 
      - 对帖子的评价不同，一个是状态，一个是类型
      - **我们获取的时候需要对帖子进行排序，置顶的在前面，若是合成一个字段，就不满足了或者说置顶就很麻烦了**

- **user**（用户信息）：
  - 用户名，密码（加密加盐后的密码），salt（盐，与密码进行拼接，再进行加密），邮箱，头像网址
  - status：0-未激活; 1-已激活;
  - type：0-普通用户; 1-超级管理员; 2-版主;【超级管理员可以拉黑，版主可以置顶，置为精华】（不同类型各司其职）
  - 激活码：发送邮件激活时，网址：http://localhost:8080/userId/激活码（加激活码的目的是：避免恶意注册）【后续也放在redis中】

- **comment（评论信息）**: 
  - usedId，评论内容
  - entity_type :被评论的实体类型：1，帖子评论，2，评论的评论。
  - entity_id：被评论的id。
  - status：状态：2为拉黑，
  - create_time创建时间
  - target_id：被评论的评论 的usedid（因为评论也可以被评论，所以区分该评论是评论的哪个评论，即A，B，C都评论了该评论，那我再评论的时需要指定是评论了哪个评论，targetId=usedId ）
  
- **message**（私信消息以及系统通知也在此处）：
  - status：1，已读，2，未读
  - from_id,to_id，
  - 内容，
  - 发送时间
  - conversation_id （表明是谁与谁的对话，小id_大id，方便搜索）
  
- **login_ticket：**
  - usedId,ticket（登录凭证），过期时间，状态
  - status： 0-有效; 1-无效（当前用户是否还在登录）。
  - - 保存登录状态，若是登录退出，将status改为1；
    - 记录用户登录信息，便于以后查询；
    - 记录用户登录的过期信息，以此区分登录时，记住我与没标记的不同过期时间
    - usedId，便于查询 以登录用户的信息
    - token：登录凭证，以此从redis中获取loginToken对象，从而找到对应的usedId
  - 为什么cookie中不直接保存used的一些信息，
    - 因为我们认为这样是不安全的，如果是token随机乱码，是安全的。usedId过于明显，容易修改冒充其他用户


# redis 信息

redis存储了

- 验证码

  - key=kaptcha:uuid，value=验证码，（在请求验证码时，会返回一个cookie，里面包含该uuid，以此来获取验证码）
  - 不需要永久存储，可以设置过期时间

- 账号激活码【邮件】激活码

  - 会发送邮件给用户，携带地址：激活链接/activation/{userId}/{code}
  - 注册时，将该code保存在redis中，并发送邮件，点击拦截后，若redis存在该code，表明注册成功，

- 登录凭证 

  - key =  ticket: 登录凭证单号，value=loginTocket
  - 因为后台在每次处理请求的时候都要查询用户的登录凭证，访问的频率非常高，因此需要使用redis存储。【由登录凭证可获取用户信息】

- 已登录用户信息

  - key=ticket:登录凭证单号：user，value=user实例
  - 每一次请求都会获取user信息，从数据库获取过去频繁，可以在redis中获取已登录的用户信息

- 点赞关注信息

-  点赞：

  - key=like：entity：entityType：entityId，value=set(userId)
  - 点赞可以是帖子，评论

- 关注

  - 分为两张表，当前用户关注了谁，和谁关注了当前用户

  - ```java
    //某个用户关注的实体
    //followee:userId:entityType --> zset(entityId,now)
    ```

  - ```java
    //某个实体拥有的粉丝
    //follower:entityType:entityId -> zset(userId,now)
    ```

  - 用zset用关注时间进行排序

# ==**方法复用,解耦**==

- 降低了解耦，提高了复用，降低了代码量

- 查询帖子，既可以查热点帖子，又可以查最新帖子（传入orderMode,进行区分）
- 查询帖子数量，可查全部帖子数量，也可查某个人的发布帖子总数量（传入userId，若userId=0表示查询全部帖子）
- 点赞数量查询，可以查询帖子点赞总数，评论点赞总数（传入帖子类型，根据类型查询，可以是帖子，评论）
- 判断当前用户对帖子，评论的点赞状态，传入实体类型（可以是帖子，也可以是评论）
- 查询会话信息的未读数量，可以复用，不传入会话Id，利用sql动态拼接，查询所有的会话的未读数量
- 统一异常处理，统一记录日志，使所有的异常外抛，抛到controller层，处理所有controller层异常的类。



# 项目梳理

- 事务：
  - 对实体（帖子，评论，用户）增删改操作时
  - 作用：添加事务，保证事务的一致性，避免因为异常导致的操作部分失败。保证四大特性：原子性，一致性，隔离性，持久性
  
- **异常统一处理**
  - **@ControllerAdvice注解**使用@ExceptionHandler创建一个新的类，来处理异常，在每个方法处理特定异常。便于后期的拓展和维护
  
- AOP
  - 统一记录日志。创建一个类，记录日志。使用了一个@Pointcut来切入位置的复用
  - before注解，在目标方法执行前，先执行该方法记录日志
  
- 拦截器，进行解耦
  - 登录后，不再显示登录注册按钮，需要判断该客户端时候登录。
  - 许多页面只面向登录用户，所以请求都需要登录检查，通过拦截器preHolder处理。查询cookie中的登录凭证 loginTicket，在redis中获取该用户。并保存在threadlocal中，避免因为多线程造成的数据混乱。
    - 由于threadlocal的复用，因为线程复用，所以threadlocal复用，在这次请求结束后，清除threadlocal中的用户信息
  - 1只解决了查询用户问题，并没有判断哪些请求该拦截哪些请求不该拦截。
    1. **为便于区分，我们新建了一个接口，设置新的拦截器，拦截题提供了handler（首先判断是否是请求方法的，若请求静态资源，则直接放行），可以获取要处理该请求的controller方法**
    2. 通过反射查找该方法是否有注解修饰，有并且没有登录，则拦截成功，并转发到登录请求
  
- 引用**Spring Security**：执行权限控制以及防止CSRF攻击
  - 权限控制
    - 原来的权限控制是：新建一个接口，修饰需要权限的方法。看拦截器的加粗部分
    - 在security配置类中指定，需要拦截的接口指定需要的用户权限。
    - 用户实现了userDetail接口，可以在数据库中查询当前用户的权限
  - **CSRF攻击：**
    - 看springSecurity中的CSRF
    - **防范方式：**
      - **在页面中默认添加一个隐藏的变量：name= `_csrf`。value=随机字符串。在哪用户发送请求不仅进行当前用户的验证，还会对csrf的token进行验证。请求头中添加这个scrf令牌。每次请求都携带令牌**
      - **异步请求Ajax需要自己设置**
        - 可以在页面自己手动获取一个隐藏的input的CSRF令牌
        - 发送AJAX请求之前,将CSRF令牌设置到请求的消息头中.
  
- **并发量**
  - 使用jm
  
- **引入Redis**

  - **使用redis遇到了什么困难嘛？**
    - spring提供的redis只有RedisTemplate《Object，Object》和StringRedisTemplate《String，String》，我一般使用的是key为String ,value为object。选择了多种方式进行保存数据。对value进行序列化操作。**构建一个新的RedisTemplate《String，Object》。对key和value进行JSON序列化**
    - 发现redis占用内存过多，可以对许多数据保存时设置过期时间。验证码，登录凭证。设置过期时间缓解redis压力


  - **点赞**
    - 判断用户登录
    - 执行点赞功能，点1下为点赞，点两下为取消点赞。
    - **事务执行**（感觉没什么特别作用）
    - 改变该被点赞用户的总赞数。redis中保存两个key 
      - 帖子key集合->包含所有点赞的用户ID
      - 用户key->被赞总数
    - 无论是帖子还是评论，给对应的实体set集合（保存有所有点赞用户Id）
      添加或移除该用户id(保存是谁点的赞)
    - **添加到消息队列**
    
  - **关注**
    - 关注分为两个key  。Zset集合，获取的时候进行按时间排序，
      - 该用户关注博主集合（key=usedId:博主 ）
      - 当前用户的粉丝列表（key:usedId）
    - 添加到消息队列
    
  - **redis的消息不一致性：**

    - 用户登录后，会返回cookie，包含内部登录凭证，凭此登录凭证，可以在redis中获取用户的id以及详细信息
    - 设置了相同的过期时间，cookie先于redis设置。所以cookie先失效，会要求再次登录，即使出现了ms级的偏差并不影响使用

  - 登录注册


    - 登录获取验证码时，会生成一个cookie（kaptchaOwner,uuid）.再向redis中保存（uuid，验证码）,请求时以此验证；
    - 第一次登录，会生成一个login_token对象,保存在redis中：key=ticket:登录凭证单号，value=loginToken对象。并且创建一个cookie，携带登录凭证单号。可以在redis中查询；
    - 登录后，用户每次请求，拦截器拦截，从cookie中获取login_token号，从redis中获取loginToken对象，在从loginToken中得到usedId，并比较是否已经过期
    - 再通过usedId查询到用户，并保存在threadLocal中。
    
    - 登录凭证作用：
      - 保存登录状态，若是登录退出，将status改为1；
      - 记录用户登录信息，便于以后查询；
      - 记录用户登录的过期信息，以此区分登录时，记住我与没标记的不同过期时间
      - usedId，便于查询 以登录用户的信息
      - token：登录凭证，以此从redis中获取loginToken对象，从而找到对应的usedId
    - 为什么cookie中不直接保存used的一些信息，
      - 因为我们认为这样是不安全的，如果是token随机乱码，是安全的。usedId过于明显，容易修改冒充其他用户

  - 注册：请求携带userName，password，email，判断用户名可以注册后，


    - 将密码与一个salt（随机数的前五位）拼接，再进行md5加密。从而实现加密加盐。验证时，通过用户名查找用户，把请求的password+salt，再通过md5加密，与查找到的用户密码对比是否相等

  - **kafka消息队列的内容**


    - 主题


        - 点赞           like
        - 关注           follow
        - 被评论       comment
        - 帖子发布   publish               //可以不说
    
    - 前三个主题共用一个消费者，传入usedid，被评论的实体，和被评论的id
    
        - 以系统向用户发送通知，并在数据库中保存会话，会话为message的JSON格式
    
    - 帖子发布，需要保存到es中。














# 1,首页

## 论坛首页

分页操作

## 步骤

- http://localhost:8080/index和http://localhost:8080/请求都会转发到/index 的controller
- orderMode为帖子形态，orderMode=0为最新的帖子排序，orderMode=1为最热的帖子排序
- 查询所有帖子数量并保存到page中。
- 查询当前页的帖子，需要传入orderMode，来指定是什么形式，最热帖子还是最新帖子
  - 若是第1页且为热点帖子，则从本地缓存中获取**（优化性能）**
    - DiscussPostServiceImpl加载时会进行初始化，使用**@PostConstruct**注解，jdk提供注解，服务器加载相关Servlet的时候运行，并且只会被服务器执行一次。这个注解：PostConstruct在构造函数之后执行，init（）方法之前执行。即容器加载时调用。
    - （caffeine每次调用，都会执行init方法中的caffeine的获取信息，并将结果返回到本地缓存对象postListCache中。所以会造成每次请求都会调用该方法的假象，实际是只执行caffeine的配置方法）
    - 方法内，使用Caffeine保存到本地缓存。只保存了最初的热点帖子。定时更新。**并保存到本地缓存，仅保存首页的热点帖子，并未保存所有的**
  - 不是，则从数据库中查询
- 遍历所有的帖子
  - 帖子保存有UsedId和帖子内容（时间，标题，内容，评论数量等信息），通过帖子查询所有的用户
  - 并查询当前帖子的点赞数，
    - 首先在redis中查询，key=user:userIdxxx   
    - 若没有查到，则从数据库中查，并保存到redis中
    - 设置过期时间为1小时
  - 将对应的帖子和用户信息，点赞信息保存在map中
- 将所有的map保存到list中，发给前端



# 2登录注册

## 2.1发送邮件

实现注册事，系统发送邮件功能

通过Spring Mail进行发送邮件功能

1. 导入jar包

   导入Spring mail starter

   
   
2. 参数配置
   在spring的xml中配置要使用的邮箱，用户名，密码等信息

   ```properties
   #MailProperties
   spring.mail.protocol=smtp
   #指定什么邮箱发送
   spring.mail.host=smtp.qq.com
   #指定发送邮箱的端口，一般为465
   spring.mail.port=465
   #指定使用那个邮箱发送，写出用户名和密码
   spring.mail.username=1446514241@qq.com
   spring.mail.password=cngiqhooakyrfhfc
   spring.mail.default-encoding=utf-8
   spring.mail.properties.mail.smtp.ssl.enable=true
   ```

   

3. 使用 JavaMailSender 发送邮件

   指定，发送人邮箱，主题，内容

   ```Java
            @Autowired
       	MailClient mailClient;
           mailClient.sendMail("要发送到哪个邮箱wyy187@tju.edu.cn","welcom主题","1245内容");
   ```

   

发送内容不只是text格式。也可以发送html格式的文件

可以通过模板引擎，设置context，将名称传入到网页，

```Java
        //导入模板引擎
		@Autowired
    	TemplateEngine templateEngine;
        Context context = new Context();
        //将设置变量，并将变量注入内容
		context.setVariable("username","wyy");
		//将html传入变量，并生成字符串
        String process = templateEngine.process("/mail/demo", context);
        mailClient.sendMail("wyy187@tju.edu.cn","HTML",process);
```

html

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>欢迎你<span style="color: red" th:text="${username}"> </span></p>
</body>
</html>
```



## 2.2注册功能

注册仅仅向邮箱添加数据，验证数据的有效性，但此处会有邮箱激活功能。本质是请求/activation/{userId}/{code}地址，服务器收到请求则激活成功。

而该请求需要在邮箱中体现。即注册用户时，通过用户设置的邮箱，发送邮件内含，激活链接/activation/{userId}/{code}，在service层，配置激活网址。用户中属性：用户状态：激活，未激活。另外还有激活验证码。可以根据激活链接进行比对。

templateEngine：模板引擎，可以我们设置的context通过模板引擎注入到已经设置好的网页，设置的网页，会将我们已经设置的数据，放在已经tx：text{key}修饰的标签中。

```Java
    public Map<String,Object> register(User user){
        HashMap<String, Object> map = new HashMap<>();
        if(user==null){
            throw new RuntimeException("用户不能为空");
        }
        if(StringUtils.isBlank(user.getUsername())){
            map.put("usernameMsg","账号不能为空");
            return map;
        }
        if(StringUtils.isBlank(user.getPassword())){
            map.put("passwordMsg","密码不能为空");
            return map;
        }
        if(StringUtils.isBlank(user.getEmail())){
            map.put("emailMsg","邮箱不能为空");
            return map;
        }
        if(userMapper.selectByName1(user.getUsername())!=null){
            map.put("passwordMsg","该用户名已经被注册");
            return map;
        }
        if(userMapper.selectByEmail1(user.getEmail())!=null){
            map.put("emailMsg","该邮箱已经被注册");
            return map;
        }
        user.setSalt(CommunityUtil.generateUUID().substring(0,5));
        user.setPassword(CommunityUtil.md5(user.getPassword()+user.getSalt()));
        user.setType(0);
        user.setStatus(0);
        user.setActivationCode(CommunityUtil.generateUUID());
        user.setHeaderUrl(String.format("http://images.nowcoder.com/head/%dt.png",new Random().nextInt(1000)));
        user.setCreateTime(new Date());
        userMapper.insertUser1(user);

        //激活邮件
        Context context = new Context();
        context.setVariable("email",user.getEmail());
        String url = domain+contextPath+"/activation/"+user.getId()+"/"+user.getActivationCode();
        context.setVariable("url",url);
        String process = templateEngine.process("/mail/activation", context);
        mailClient.sendMail(user.getEmail(),"激活账号",process);

        return map;
    }
```

在controller中，有一个新的方法专门处理是否激活，重复激活等问题

在用户属性中，有一个专门的属性表明为是否激活信息，另外创建了激活接口的各个属性，让service与controller实现，从而进行判断

```java
public interface CommunityConstant {
    /**
     * 激活成功
     */
    int ACTIVATION_SUCCESS = 0;
    /**
     *  重复激活
     */
    int ACTIVATION_REPEAT = 1;
    /**
     * 激活失败
     */
    int ACTIVATION_FAILURE = 2;
}
```



```Java
   @RequestMapping(path = "/activation/{userId}/{code}",method = RequestMethod.GET)
    public String activation(Model model, @PathVariable int userId,@PathVariable String code){
        int activation = userService.activation(userId, code);
        switch (activation){
            case ACTIVATION_SUCCESS:
                model.addAttribute("msg","恭喜您，激活成功");
                model.addAttribute("target","/login");
                break;
            case ACTIVATION_REPEAT:
                model.addAttribute("msg","无效操作，您的用户已经激活");
                model.addAttribute("target","/index");
                break;

            case ACTIVATION_FAILURE:
                model.addAttribute("msg","激活失败");
                model.addAttribute("target","/index");
                break;
        }
        return "/site/operate-result";
    }
```

## 2.3验证码问题

通过kaptcha在controller层生成验证码图片以及对应的文字答案。将文字答案保存在session中，方便登录验证的时候获取。

验证码的生成需要配置一个配置类，设置验证码内容，大小等信息。

- 导入jar包

导入kaptcha包

```xml
        <!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha -->
        <dependency>
            <groupId>com.github.penggle</groupId>
            <artifactId>kaptcha</artifactId>
            <version>2.3.2</version>
        </dependency>
```

- 设置配置类，设置验证码的格式以及内容等信息

在此配置类下，返回的Producer，可以直接获取内容以及图片。

```Java
@Configuration
public class KaptchaConfig{
    /**
     * 生成验证码
     * @return
     */
    @Bean
    public Producer kaptchaProducer(){
        //设置kaptcha的配置信息
        Properties properties = new Properties();
        properties.setProperty("kaptcha.image.width","100");
        properties.setProperty("kaptcha.image.height","40");
        properties.setProperty("kaptcha.textproducer.font.size","32");
        properties.setProperty("kaptcha.textproducer.font.color","0,0,0");
        properties.setProperty("kaptcha.textproducer.char.string","0123456789ZXCVBNMASDFGHJKLQWERTYUIOP");
        properties.setProperty("kaptcha.textproducer.char.length","4");
        properties.setProperty("kaptcha.noise.impl","com.google.code.kaptcha.impl.NoNoise");
        //创建默认的kaptcha
        DefaultKaptcha kaptcha = new DefaultKaptcha();
        //传入默认的kaptcha
        Config config = new Config(properties);
        kaptcha.setConfig(config);
        return kaptcha;
    }
}
```

- 设置controller请求，生成并响应图片以及内容

```Java
    @RequestMapping(path = "/kaptcha", method = RequestMethod.GET)
    public void getKaptcha(HttpServletResponse response, HttpSession session) {
        //生成验证码
        String text = kaptchaProducer.createText();
        BufferedImage image = kaptchaProducer.createImage(text);
        //将验证码存入session
        session.setAttribute("kaptcha",text);

        //将图片输出给游览器
        response.setContentType("image/png");
        try {
            ServletOutputStream stream = response.getOutputStream();
            ImageIO.write(image,"png",stream);
        } catch (IOException e) {
            LOG.error("验证码响应失败："+e.getMessage());
        }
    }
```

## 2.4登录、退出功能

登录过程会验证，用户名，密码，验证码。前两个可以在数据库中获取最后一个,在session中获取.因为在设置验证码的时候,保存带session中.

另外,登录页面,会产生一个登录凭证,在访问过程中保存恢复该用户的信息.只有根据该用户凭证才能获取该用户的信息.该凭证为一个ticket类，另外在数据库中有设置。

在登录过程中，会首先验证验证码，用户名，密码信息。验证完后，会设创建一个ticket对象，（包括user_id  ticket，status，expired（有效时间）），并加入到数据库。其内部属性ticket是唯一的。我们创建了一个Cookie，并将该内部属性ticket保存在cookie中。在页面访问中，服务器根据ticket查询数据库，可以查到用户id，就是可以查询到用户信息。就是能知道是哪个用户在访问。

登出过程，将数据库保存的ticket对象，的内部属性status状态改为1。

## 2.5显示登录信息

登录后，可以显示用户名等信息并隐去注册，登录等链接，未登录，则显示注册，登录，不显示用户头像等信息。

我们选择拦截器来获取对象信息。每次请求（不包括静态请求），通过拦截器拦截。又用户登录的话，cookie中有“ticket”。可以根据该ticket属性，获取`login_ticket`的数据，从而获得userID属性，进而得知是哪个用户在请求。并将用户信息保存起来。

获取用户信息，由于服务器处理请求会使多线程的，所以获取对象，并获取保存中会出现混乱，所以我们需要将保存users也用多线程的，因为服务器处理请求是多线程的，可能并发处理请求，保存user对象，若保存在一个位置，而一定会有顶替原来的数据，所以不能使用session保存对象。使用线程`ThreadLocal`保存数据.

```Java
@Component
public class HostHolder {
    private ThreadLocal<User> users = new ThreadLocal<>();
    public void setUsers(User user){
        users.set(user);
    }
    public User getUser(){
        return users.get();
    }

    public void clear(){
        users.remove();
    }
}
```

通过该方法保存和获取该线程的用户。

拦截器，在执行目标方法执行，进行拦截，并获取用户信息并保存在该线程中。在执行完目标方法后，在调用postHandle方法，获取该线程的用户对象，并将其加入到modelandview中，使其进行渲染。

## 2.6账号设置

上传头像，可以上传设置自己的头像。自己的头像上传到服务器，在服务器中进行保存。并将数据库中用户的headerUrl属性进行修改。headerUrl依然是一个web网址，我们再设置一个controller方法，来处理该请求，在登录后，头像会发送请求，服务器收到请求，读取之前存入服务器的头像，并response返回给用户。

在服务器保存图片时，为防止上传图片名重复，我们进行了重新命名，在原图片名的基础上加入UUID。并将图片名字加入到user对象的HeaderUrl。所以在请求时，则直接知晓了该用户的头像名称。

```Java
   @RequestMapping(path = "/setting", method = RequestMethod.POST)
    public String updateHeadler(MultipartFile multipartFile, Model model) throws RuntimeException {
        if (multipartFile.isEmpty()) {
            model.addAttribute("error", "上传文件不能为空");
            return "/site/setting";
        }
        String filename = multipartFile.getOriginalFilename();
        String suffix = filename.substring(filename.lastIndexOf("."));

        if (StringUtils.isBlank(suffix)) {
            model.addAttribute("error", "上传文件格式不正确");
            return "/site/setting";
        }
        filename = CommunityUtil.generateUUID() + suffix;
        File file = new File(uploadPath + "/" + filename);

        try {
            multipartFile.transferTo(file);
        } catch (IOException e) {
            LOG.error("上传文件失败" + e.getMessage());
            throw new RuntimeException("上传文件失败,服务器异常" + e.getMessage());
        }
        String headlerUrl = domain + contextPath + "/user/headerurl/" + filename;
        userService.updateHeaderUrl(hostHolder.getUser().getId(), headlerUrl);
        return "redirect:/index";
    }

    @RequestMapping(path = "/headerurl/{filename}", method = RequestMethod.GET)
    public void getHeadler(@PathVariable("filename") String filename, HttpServletResponse response) throws RuntimeException {
        //设置服务器存放地址
        filename = uploadPath +"/"+ filename;
        //获取文件后缀
        String suffix = filename.substring(filename.lastIndexOf("."));

        try (
                FileInputStream fileInputStream = new FileInputStream(filename);
        ) {
            ServletOutputStream outputStream = response.getOutputStream();

            byte[] bytes = new byte[1024];
            int b = 0;
            while ((b = fileInputStream.read(bytes)) != -1) {
                outputStream.write(bytes, 0, b);
            }
        } catch (IOException e) {
            LOG.error("读取文件失败" + e.getMessage());
        }
    }
```

## 2.7检查登录装填

在一些网页需要登录才能进行访问，比如账号设置。因此，我们需要将一些网址进行拦截。但指定方法进行拦截，过于费力，所以选择自定义注解，并通过注解拦截。有该注解修饰的，并用户登录的，则放行，否则拦截。

在拦截器中，首先判定请求是否为方法，再获取该方法，并判断该方法是否有LoginRequired注解修饰，有的话，则判断用户是否登录。

```Java
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if(handler instanceof HandlerMethod){
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Method method = handlerMethod.getMethod();
            LoginRequired annotation = method.getAnnotation(LoginRequired.class);
            if(annotation!=null&&hostHolder.getUser()==null){
                response.sendRedirect(request.getContextPath()+"/login");
                return false;
            }
        }
        return true;
    }
```

自定义注解

```Java
//指定注解修饰的范围，指定为修饰方法
@Target(ElementType.METHOD)
//为运行时注解，表示不会在编译时丢失
@Retention(RetentionPolicy.RUNTIME)
public @interface LoginRequired {

}
```

## 注册功能实现

- 发送register请求，转发到register页面
- 将请求信息，直接封装为user。
- service层：
  - 判断：用户名，密码，邮箱不能为空。用户名，邮箱均未被其他人注册
  - **获取一串随机字符串，与用户密码拼接，然后再进行md5加密**（加密加盐操作）
  - **设置激活码，并保存到用户**，
  - 保存用户信息（用户名，加盐加密后的密码，状态，创建时间，用户头像，状态，类型）
  - 发送激活邮件
    - 导入spring-mail包，写配置（邮箱类型qq.com，邮件）
    - 配置包括，用户名，密码（并不是真正密码，而且一个字符串，可以向邮件服务器提交，用户名，密码，邮件进行发送，并没有真正登录邮箱）
    - 将邮件发送配置封装为一个工具类
  - 激活邮件包含：网址http://localhost:8080/{userId}/{随机字符串}，包含userId来激活指定用户，随机字符串来避免随意激活，将随机字符串与保存在用户的随机字符串进行比较，若相同，则激活。
  - 保存激活码到redis中
  - 随机字符串保存到redis中，key=register：userId,value=随机字符串。
  - 邮件的激活网址，请求到服务器，若相同，则激活成功，并删除redis中的激活码。
  - 更新数据库中user的状态
- 若用户名，密码，邮箱等信息，出现问题，则保存到model返回到页面。

## 登录功能实现

- 验证码部分

  - 使用kaptcha生成验证码，异步请求
  - 为区别不同用户的验证码，每次请求验证码会向客户端添加cookie，key=统一mingc,value=UUID.  
  - 将验证码保存到redis中，key=UUID,value=验证码。设置过期时间

- 登录请求

  - 首先判断用户名，密码，验证码不为空
  - service层查询
    - 通过用户名查询用户
    - 根据密码和盐拼接，与用户密码进行判断
    - 使用令牌机制：创建一个loginTicket对象，
  - 验证完成后，创建一个cookie，保存loginTicket的令牌，返回到客户端，并将对应的user信息保存到redis中。
  - **验证登录**设置拦截器，每次请求会根据请求中loginTicket来判断时候登录，若已经登录，则在根据loginTicket令牌信息查询到登录用户，保存到threadlocal中。方便调用

- 登录功能的拓展

  1. 许多页面只面向登录用户，所以请求都需要登录检查，通过拦截器preHolder处理。查询cookie中的登录凭证 loginTicket，在redis中获取该用户。并保存在threadlocal中，避免因为多线程造成的数据混乱
  2. 1只解决了查询用户问题，并没有判断哪些请求该拦截哪些请求不该拦截。
     1. **为便于区分，我们新建了一个接口，设置新的拦截器，拦截题提供了handler（首先判断是否是请求方法的，若请求静态资源，则直接放行），可以获取要处理该请求的controller方法**
     2. 通过反射查找该方法是否有注解修饰，有并且没有登录，则拦截成功，并转发到登录请求




# 3评论私信功能

## 3.1过滤敏感词

我们选择设置前缀树，来检测敏感词问题。性能很快。首先创建一个树，里面每一层包含一个敏感字符，若到最后一层，则验证为敏感字符，则将敏感字符用*替代。另外，考虑到一些使用者在发送敏感字符时，会将敏感字拆分，中间加上特殊字符，所以我们另外添加了一个验证方法，若为特殊字符则跳过该字符，继续验证。然后再插入帖子，在service层进行敏感词的检测，并存入数据库。最终显示。

![image-20220306210256128](%E5%A4%8D%E4%B9%A0/image-20220306210256128.png)

```Java
public class SensitiverFilter {
    private static final Logger LOG = LoggerFactory.getLogger(SensitiverFilter.class);

    private TrieNode root = new TrieNode();

    @PostConstruct
    public void init() {

        try (
                InputStream is = this.getClass().getClassLoader().getResourceAsStream("sensitive-words.txt");
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));
        ) {
            String keyWord;
            while ((keyWord = bufferedReader.readLine()) != null) {
                this.addkeyWord(keyWord);
            }
        } catch (IOException e) {
            LOG.error("加载敏感词失败：" + e.getMessage());
        }
    }

    public void addkeyWord(String keyWord) {
        TrieNode temp = root;
        for (int i = 0; i < keyWord.length(); i++) {
            char c = keyWord.charAt(i);
            TrieNode trieNode = temp.getKeyWord(c);
            if (trieNode == null) {
                trieNode = new TrieNode();
                temp.addKeyWord(c, trieNode);
            }
            temp = trieNode;
            if (i == keyWord.length() - 1) {
                temp.setKeyWordEnd(true);
            }
        }
    }

    public String filter(String text){
        if(StringUtils.isBlank(text)){
            return null;
        }
        StringBuilder builder = new StringBuilder();
        String REPLACEMENT = "*";
        TrieNode temp = root;
        int begin = 0,end = 0;

        while (begin<text.length()){
            char c = text.charAt(end);

            TrieNode keyWord = temp.getKeyWord(c);
            if(isSymbol(c)){
                if(begin==end){
                    builder.append(text.substring(begin++,end+1));
                }

            }else if(keyWord==null){
                builder.append(text.substring(begin,end+1));
                temp = root;
                begin = end+1;
            }else{
                if(keyWord.isKeyWordEnd){
                    for(;begin<=end;begin++){
                        builder.append(REPLACEMENT);
                    }
                    temp = root;
                }else{
                    temp = keyWord;
                }
            }
            end++;
            if(end==text.length()){
                builder.append(text.substring(begin,end));
                break;
            }
        }
        return builder.toString();
    }

    private boolean isSymbol(char c){
        return !CharUtils.isAsciiAlphanumeric(c)&&(c<0x2E80||c>0x9FFF);
    }



    /**
     * 前缀树，过滤敏感词
     */
    private class TrieNode {
        //关键字结束标识
        private boolean isKeyWordEnd = false;

        public boolean isKeyWordEnd() {
            return isKeyWordEnd;
        }

        public void setKeyWordEnd(boolean keyWordEnd) {
            isKeyWordEnd = keyWordEnd;
        }


        private HashMap<Character, TrieNode> map = new HashMap<Character, TrieNode>();

        public void addKeyWord(Character c, TrieNode trieNode) {
            map.put(c, trieNode);
        }

        public TrieNode getKeyWord(Character c) {
            return map.get(c);
        }
    }

}
```

3.2发布帖子



## 3.24私信列表

在私信列表中，首先需要所有的信息。一定要注意表的构建。因为要包含用户信息（userId），消息是由谁发给谁，所以是（fromUserId）->(toUserId),另外，为了方便在点开个人私信后，显示两个人的对话，再添加了一个conversationId（小的id_大的id）这样，直接获取二人的对话。无论是发送者还是接收者，私信框是一样的。

另外



## 3.31统一异常处理

统一记录异常，因为所有异常抛出，最终都会到controller层。所以我们只处理controller层异常。将其进行拦截。并记录。

@ControllerAdvice(annotations = Controller.class)可以指定为异常配置类。设置的异常在此处处理。另外再方法出标注@ExceptionHandler({Exception.class})。在这种方法下，符合指定异常的异常，则进入该方法

![image-20220308194810362](%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B/image-20220308194810362.png)

值得注意的是，

- 我们处理异常后，还会返回自己制作的错误页面。以提高观赏性。（在资源文件下 error文件夹/404.html）这种格式
- 但方法不能返回字符串。所以需要response参数，指定重定向网址
- 需要request参数来判断是否为异步请求，以为异步请求不用重定向，只需要返回Ajax即可

```Java
@ControllerAdvice(annotations = Controller.class)
public class ExceptionAdvice {
    private static final Logger LOG = LoggerFactory.getLogger(ExceptionAdvice.class);
    @ExceptionHandler({Exception.class})
    public void handleExection(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException {
        LOG.error("服务器发生异常："+e.getMessage());
        //记录每一条异常信息
        for (StackTraceElement element : e.getStackTrace()) {
            LOG.error(element.toString());
        }
        String xRequestWith = request.getHeader("x-requested-with");
        //判断请求是异步请求还是同步请求，即是ajax请求还是普通请求，请求跳转
        if("XMLHttpRequest".equals(xRequestWith)){
            response.setContentType("applica/plain;charset=utf-8");
            PrintWriter writer = response.getWriter();
            writer.write(CommunityUtil.getJSONString(1,"服务器异常"));
        }else{
            response.sendRedirect(request.getContextPath()+"/error");
        }

    }
}
```

## 3.33统一记录日志

统一记录日子，因为在controller层直接添加日志，使得系统日志需求与软件控制器需求发生了耦合。所以选择AOP进行日志添加。另外AOP在一个类中，方便日志的管理，而不是在每个想要加入的方法中添加日志操作。

```Java
@Aspect
@Component
public class ServiceLogAspect {

    private static final Logger LOG = LoggerFactory.getLogger(ServiceLogAspect.class);

    @Pointcut("execution(* com.newcoder.community01.service.*.*(..))")
    public void pointcut(){ }

    @Before("pointcut()")
    public void before(JoinPoint joinPoint){
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = requestAttributes.getRequest();
        String ip = request.getRemoteHost();
        String now = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
        String target = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName();
        LOG.info(String.format("用户[%S],在[%S],访问了[%S].",ip,now,target));
    }
}

```

## ==敏感词过滤（前缀树）==

- 前缀树，为多子树，
  - root节点不保存信息，子树保存在map中。每一个char对应一个Tree节点。
  - 每个Tree节点保存子树map，Boolean 为结束节点，
- 对一个string进行敏感词过滤，使用双指针的方式，遍历String与前缀树的数值进行比对，若相同，则替换为`**`，若不相同，则l++。继续判断。
- 若有特殊字符分割，如：赌**博，则跳过特殊字符，继续判断

## ==发布帖子和==

- 接收到请求信息title和context，首先将帖子信息http的转换，避免用户写入网址的特殊符号 <h1> 你好 </h1>,再进行敏感词过滤
- 帖子保存内容，时间，usedId，保存到数据库

## ==查看和评论帖子功能==

- **查看**，评论即添加一个新的数据到数据库
  - 查询请求的帖子，通过帖子查找帖子信息和用户信息
  - 查找帖子的点赞数量，并判断当前用户是否点赞了该帖子(redis)
    - 以set集合保存当前帖子的点赞的所有用户，计算数量
    - 查找当前set集合是否包含当前用户Id，判断点赞状态
  - 查找评论：给帖子的评论,给评论的评论
    - 遍历帖子的所有评论，查找用户，点赞数量，当前用户的点赞状态
    - 遍历每个评论的所有评论，查找要回复的用户，点赞数量，当前用户的点赞状态

- **查看私信功能**
  - 查看消息会话
    - 查询用户会话。from_id,或者to_id为usedId,则返回id
    - 列出当前页的所有会话。遍历每个会话的信息总数量，未读数量，目标用户信息
    - 查询未读信息数量（解耦复用），查询未读通知数量
  - 查看具体会话
    - 查看此会话当前页的所有私信，遍历私信将查找收信的信息
    - 将所有的信息设为已读

==统一异常处理==

使用注解@controllerAdvice，指定异常处理信息，看3.31

==统一记录日志==

通过AOP将访问方法时，记录日志

# 4，Spring整合Redis

由于spring中的key，value为object-object类型。我们一般使用string-object的方式，所以我们需要自己配置（创建配置类，添加@Bean）。指定我们要使用的类型。我们这里使用string和map

```Java
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory factory){
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        //指定key序列化方式
        template.setKeySerializer(RedisSerializer.string());
        //指定value的序列化方式
        template.setValueSerializer(RedisSerializer.json());
        //hash的key序列化方式
        template.setHashKeySerializer(RedisSerializer.string());
        //hash的value序列化方式
        template.setHashValueSerializer(RedisSerializer.json());

        //更新设置
        template.afterPropertiesSet();
        return template;
    }
}
```

编程式事务，创建redisTemplate.execute()并传入new SessionCallback()。重写执行方法。在方法内部：

operations.multi();开启事务

return operations.exec();执行事务，并返回执行后结果。

在开启事务，未执行时，则方法不会真正执行，即无法获得其值

```java
@Test
void contextLoads27() {
    Object execute = redisTemplate.execute(new SessionCallback() {
        @Override
        public Object execute(RedisOperations operations) throws DataAccessException {
            operations.multi();

            String redisKey = "test:count";
            operations.opsForValue().set(redisKey, 1);
            
            System.out.println(operations.opsForValue().get(redisKey));
            System.out.println(operations.opsForValue().increment(redisKey));
            System.out.println(operations.opsForValue().decrement(redisKey));
            return operations.exec();
        }
    });
    System.out.println("execute = " + execute);

}
```



## 4.10点赞

配置一个Redis的service类，以及controller类。service层直接读取或者设置redis的值。首先为，读取赞的状态（该用户以点赞则改为已赞，否则为赞），赞的数量，然后还有点赞，再点，则取消点赞。全部在redis层进行操作。

值得一提的是，帖子，评论，回复都需要查看点赞的状态，个数。所以需要在原来的controller中响应获取

创建一个Util，将redis数据中的key确定：key的格式是like：entity：entityType：entityId。这样就其可以出事帖子还是评论，也可以指定是评论给哪个用户

```Java
public class RedisKeyUtil {
    public static final String SPLIT=":";
    public static final String PREFIX_ENTITY_LIKE="like:entity";

    //获取某个实体的赞
    //redis格式，起名为此命名，指定评论类型，id，并用set保存userid，以此不重复保存，而且可以保存用户信息可得知是哪个人点赞
    //like：entity：entityType：entityId->set(userId)
    public static final String getEntityLikeKey(int entityType,int entityId){
        return PREFIX_ENTITY_LIKE+SPLIT+entityType+SPLIT+entityId;
    }
}
```

传入帖子类型以及帖子id，指定为是评论，还是回复，以及是给哪个帖子的评论

- 在service层，将设置点赞。以及controller层的设置

```Java
@Service
public class LikeService {
    @Autowired
    private RedisTemplate redisTemplate;
    //点赞
    public void like(int entityType,int entityId,int userId){
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
        Boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);
        if(isMember){
            redisTemplate.opsForSet().remove(entityLikeKey,userId);
        }else{
            redisTemplate.opsForSet().add(entityLikeKey,userId);
        }
    }

    //查询某实体顶赞的数量
    public long findENtityLikeCount(int entityType,int entityId ){
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
        return redisTemplate.opsForSet().size(entityLikeKey);
    }

    //查询某人对某实体的点赞状态
    public int findEntityLikeStatus(int entityType,int entityId,int userId){
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
        Boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);
        return isMember? 1:0;
    }
}
```



```Java
@Controller
public class LikeController {

    @Autowired
    LikeService likeService;
    @Autowired
    HostHolder hostHolder;

    @RequestMapping(path = "/like",method = RequestMethod.POST)
    @ResponseBody
    public String like(int entityType,int entityId){
        User user = hostHolder.getUser();
        likeService.like(entityType,entityId,user.getId());

        long likeCount = likeService.findENtityLikeCount(entityType, entityId);
        int likeStatus = likeService.findEntityLikeStatus(entityType, entityId, user.getId());

        HashMap<String, Object> map = new HashMap<>();
        map.put("likeCount",likeCount);
        map.put("likeStatus",likeStatus);

        return CommunityUtil.getJSONString(0,null,map);
    }
}
```

## 4.16关注，取消关注

##  4.19关注列表、粉丝列表

- 可以在个人中心查看谁关注了该用户，已经该用户关注了谁。由于在redis存储数据时，就设置了两个表，根据该用户信息传入，进行查询。

- 另外有关注时间。即用户什么时候关注的，信息。因为在zset中，保存了now信息
- 在博主还是粉丝时，选择倒序查询（以关注时间为序），因为首先显示最近关注的人

在redis设置了两个表：

```Java
//某个用户关注的实体
//followee:userId:entityType --> zset(entityId,now)
```

以及：

```Java
//某个实体拥有的粉丝
//follower:entityType:entityId -> zset(userId,now)
```

![image-20220314184955818](%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B/image-20220314184955818.png)

## 4.23优化登录模块



![image-20220314194123858](%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B/image-20220314194123858.png)

为了对登录用户进行验证，或者说，判断当前用户，因为redis中保存了验证码信息。所以首先不能用userId来作为redis的key，因为用户还没登录。我们选择一个随机字符串最为id。kaptcha：随机字符串  作为key。在进入登录页面首先保存一个cookie，保存有随机字符串，这样才请求时可以判断是当前用户的验证码信息。

- 注意redis中可以存储对象（需序列化），获取时虽然是object对象，可以转换



保存用户信息：

- 首先selectUserById从内存中获取，若获取为null，再从数据库中获取，再保存到redis。
- 若user用户发生变化，要清除缓存中的数据



## ==Redis功能==

- **点赞**
  - 判断用户登录
  - 执行点赞功能，点1下为点赞，点两下为取消点赞。
  - **事务执行**（感觉没什么特别作用）
  - 改变该被点赞用户的总赞数。redis中保存两个key 
    - 帖子key集合->包含所有点赞的用户ID
    - 用户key->被赞总数
  - 无论是帖子还是评论，给对应的实体set集合（保存有所有点赞用户Id）
    添加或移除该用户id(保存是谁点的赞)
  - **添加到消息队列**
- **关注**
  - 关注分为两个key  。Zset集合，获取的时候进行按时间排序，
    - 该用户关注博主集合（key=usedId:博主 ）
    - 当前用户的粉丝列表（key:usedId）
  - 添加到消息队列
- redis的消息不一致性：
  - 用户登录后，会返回cookie，包含内部登录凭证，凭此登录凭证，可以在redis中获取用户的id以及详细信息
  - 设置了相同的过期时间，cookie先于redis设置。所以cookie先失效，会要求再次登录，即使出现了ms级的偏差并不影响使用



# 5，加入Kafka

Kafka就是一个阻塞队列，它是生产者生产node进入队列，消费者消费node弹出队列。



生产者-消费者模式

![image-20220324151812028](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220324151812028.png)

触发事件后，将事件放入消息队列

创建一个消息者，一个生产者，将两个读取和放入。生产者直接将消息放入消息队列，而消费者将消息放入数据库，让其他人从数据库中请求



为什么用消息队列

生产者只需要生产消息，不用关注消息如何处理，降低了耦合，并发处理，**异步处理。**消费者处理消息。

**万物皆对象的体现**

以一种事件的方式作为消息发送。封装事件对象，开发事件的生产者，开发事件的消费者。



消息队列发送value字符串

- 将对象转换为字符串

```
JSONObject.toJSONString(envent)
```

发送value为字符串，为什么是json转换成字符串，是因为在消费者可以很容易再转换为event对象

- json将字符串再转换成对象

```
JSONObject.parseObject()
```



![image-20220324184513179](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220324184513179.png)

上面仅仅是把事件放入消息队列和从消息队列中取出

显示系统通知：

首先查看系统系统，分为评论，赞，关注。用了三主题，

- 查看某个主题下最新的消息（在系统通知能看到最新一条消息），
- 某个主题下未读消息的数量（通过status获取状态）
- 某个主题下所有会话数量
- 某个主题下所有的消息（即查看所有的点赞或者所有的评论）

所有的主题下的消息都包括，发送者是谁，接收者是谁。和消息通知



系统未读通知和私信未读都会显示，所有点开消息就要获取两个未读的消息

另外但是用户登录，都可在消息处显示私信消息和系统通知未读消息的综合。所以，需要将所有未读消息进行累加，用户一旦登录就显示。选择拦截器进行获取数据。



点开这三个主题之一，会显示所有的该主题下的信息。点击每一个信息可以跳转到响应的网页，即（评论，回复会跳转到当前贴。点赞会跳转到用户个人中心）

设置网址为系统设置的，可以记录postId，即请求的帖子编号。获取用户中心编号



# 6，Elasticsearch入门

索引--->行

类型--->表

文档--->行

字段--->字段



插入一条数据：即获取到原来的数据，直接传入对象即可

```
discussPostRepository.save(discussPostMapper.selectDiscussPostById(241));
```



保存多条数据

```Java
discussPostRepository.saveAll(discussPostMapper.selectDiscussPost(101,0,100));
```

删除

```
discussPostRepository.deleteById(231);
```

修改与保存相同，可以覆盖保存



![image-20220325180144337](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220325180144337.png)

使用Es实现该功能

搜索操作也为异步操作，即需要消息队列



# 7，Spring Security

![image-20220328100548907](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220328100548907.png)



- 废弃原来的filter，没什么可说的
- 进行授权配置
  - 权限也分两种，一种是普通用户的权限，一种是超级用户的权限，即授权需要设置两次
  - 权限处理
    - 若没登录的权限处理
    - 登录，但是权限不足的处理
  - 配置授权的权限，要注意区分，请求是Ajax请求还是同步请求，不同的处理方式
- 认证方案：
  - 选择自己的认证方案即，判断是否已经登录，根据ticket来判断是够已经登录，登录的话，**构建用户认证的凭证，并存入securityContext，以便于security进行授权**
  - 在登出的时候注意清除securityContext凭证，与hostholder中的user一起清除
- csrf：（由于我们的ticket是保存在cookie中，若客户访问其他页面，也可能获取到了该cookie，那么就可以代替该用户进行非法操作）
  - spring security默认开始csrf令牌机制，会该用户页面添加一个隐藏令牌，随机字符串。spring security会进行对比。若与页面相同，则让其进行操作。若是同步请求，会带上csrf令牌，若是异步请求，则需要自己手动添加到请求末尾处

因为实现spring security，需要写一个配置类

下面是例子

```Java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserServiceImpl userService;
    //    AuthenticationManager  认证的核心接口
//    AuthenticationManagerBuilder 用于构建AuthenticationManager对象的工具
//    ProviderManager AuthenticationManager接口的默认实现类

    /**
     * 设置认证规则，选择自定义认证，设置认证的相关权限
     * @param auth
     * @throws Exception
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        /**
         * 自定义认证规则
         * AuthenticationProvider：ProviderManager持有一组AuthenticationProvider，
         *          每个AuthenticationProvider负责一种认证
         *             因为登录可能是多样的，扫码，微信登录，qq登录，用户名密码登录
         */
        auth.authenticationProvider(new AuthenticationProvider() {
            /**Authentication：用于封装认证信息的接口，不同的实现类代表不同类型的认证信息
             *
             * @param authentication
             * @return
             * @throws AuthenticationException
             */
            @Override
            public Authentication authenticate(Authentication authentication) throws AuthenticationException {
                String username = authentication.getName();
                String password = (String) authentication.getCredentials();

                User user = userService.selectByName1(username);
                if(user==null){
                    throw new UsernameNotFoundException("账号不存在");
                }

                password = CommunityUtil.md5(password+user.getSalt());
                if(user.getPassword().equals(password)){
                    throw new BadCredentialsException("密码不正确");
                }

                // Principal:主要信息  credentials：证书
                return new UsernamePasswordAuthenticationToken(user,user.getPassword(),user.getAuthorities());
            }

            /**
             * 当前的authenticationProvider支持哪种认证
             * @param aClass
             * @return
             */
            @Override
            public boolean supports(Class<?> aClass) {
                return UsernamePasswordAuthenticationToken.class.equals(aClass);
            }
        });
    }



    @Override
    public void configure(WebSecurity web) throws Exception {
        //节省判断资源，静态资源随意访问
        web.ignoring().antMatchers("/resources/**");
    }

    /**
     * 登录时的配置
     * @param http
     * @throws Exception
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //登录的配置
        http.formLogin()
                .loginPage("/loginpage")
                .loginProcessingUrl("/login")
                .successHandler(new AuthenticationSuccessHandler() {
                    @Override
                    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
                        response.sendRedirect(request.getContextPath()+"/index");
                    }
                })
                .failureHandler(new AuthenticationFailureHandler() {
                    @Override
                    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {
                        request.setAttribute("error",e.getMessage());
                        request.getRequestDispatcher("/loginpage").forward(request,response);
                    }
                });
        http.logout()
                .logoutUrl("/logout")
                .logoutSuccessHandler(new LogoutSuccessHandler() {
                    @Override
                    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
                        response.sendRedirect(request.getContextPath()+"/index");
                    }
                });

        //授权配置
        http.authorizeRequests()
                .antMatchers("/letter").hasAnyAuthority("USER","ADMIN")
                .antMatchers("/admin").hasAnyAuthority("ADMIN")
                .and().exceptionHandling().accessDeniedPage("/denied");
    }
}

```

## 7.2置顶，加精，删除

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fd26d10ed814b6489153c044f7851e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

- 置顶，加精，都会触发发帖事件，更新到es中，来实现es的排序问题

- 使用spring security可以增加权限。通过异步请求的方式

  - 通过在spring配置类中添加

    - ```
      .antMatchers(
                              "/discuss/top",
                              "/discuss/wonderful"
                      )
                      .hasAnyAuthority(
                              AUTHORITY_MODERATOR
                      )
      ```

      指定什么请求需要有什么权限。

      这种权限LoginTicketInterceptor中已经添加到该用户了

  - 在页面添加sec:authorize="hasAnyAuthority('moderator')"  页面端通过此判断当前用户，是否有该权限，有则显示，没有则不显示

## 7.3数据统计

![image-20220328145313549](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220328145313549.png)

UV可以计算不登录的用户访问：记录一天的访问量

DAU 需要用户登录才能作为数据：

- Redis HyperLogLog 是用来做基数统计的算法，基数即不重复的数据
  - 在一个key中插入多个值，可以基数
  - 有0.81%左右的误差，但是内存占用极小，
  - HyperLogLog 还可以计算多个key联合之后的key

![image-20220328152931012](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220328152931012.png)



UV使用HyperLogLog  key=uv:日期  value=IP

DAV使用bitmap  key = dav:日期 value=UserID

## 7.4热帖排行

每隔5分钟计算一次热点公式，但不是计算所有的帖子，否则帖子过多，会导致计算缓慢。所以选择将5分钟内修改的帖子放入一个缓存（redis），定时计算时只计算修改的帖子公式。

公式

log(精华分 + 评论数 * 10 + 点赞数 * 2)+（发布时间 - 牛客纪元）



间隔时间内，对帖子的发帖、点赞，评论帖子、加精时计算帖子分数，

- 在这响应controller中，传入响应的帖子编号postId。
- 注意：评论帖子，和点赞帖子才可以，点赞评论和回复评论不能计算分数
- 在redis中数据类型为set。避免重复计算
- index页面有一个热帖排行，所以在倒序排列。由于都在index页面，也是分页，所以选择将原来的index页面的Mapper拓展为添加动态SQL，
  - 若是热帖模式 ordermode=1，则以score优先倒序
  - 否则选择时间倒序ordermode=0



## 7.5头像上传至云服务器

不再保存在服务器，而是云库中。选择七牛云

- 在请求七牛云时，要有该云的token和key，，而且请求为post请求，所有在进入账号设置页面时，就要这些参数带上，随机生成的token（令牌）和key（文件名）
- 还有设置一个StringMap保存信息
- 我们覆盖了原来的文件名，选择为UUID，避免直接覆盖，这样以后可以进行查看足迹（即之前的各种头像）
- 上传到云服务器后，将网址改为url/文件名，并更新到数据库的user表

（上传七牛云，更换头像直接上传到服务器，并上传时需要的token和key已经在请求体中）

**保存到阿里云服务器**

- 首先将图片上传到服务器，服务器对阿里云服务器进行配置
- 将SpringMVC接收到的multipartFile转换成file。获取multipartFile的文件流保存到一个临时文件，并将这个文件作为file返回
- 将file上传至阿里云服务器
- 并将该头像的名称网址更新到DB-user中。



#### 对象存储流程

- 方式1：用户提交到服务器，服务器再提交到OSS云存储
  - 过于慢，浪费资源
- 方式2：用户直接提交到OSS云存储，需要服务器将id发送给客户，客户再提交
  - 会暴露OSS云存储的accessKeyId和accessKeySecret，**不安全**
- **方式3：**用户向服务器请求一个Policy，用户凭借此Policy向OSS发送数据，Policy封装了OSS保存的信息，安全，且省资源**（目前使用）**

Policy：为当前云服务器的一个临时授权账号，可以申请传入

**流程**

1. 用户发送上传Policy请求到应用服务器。
2. 应用服务器返回上传Policy和签名给用户。
3. 用户直接上传数据到OSS。





## 7.6优化网站

![image-20220329145413017](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220329145413017.png)

采用多级缓存，

- 一级缓存为服务器本地缓存，
- 二级缓存在redis
- 最后为数据库

本地缓存与redis的区别：可能以后用作分布式，多台服务器，本地缓存局限于本台服务器，而redis和数据库为多台服务器都能访问

避免缓存雪崩，所有请求落在db



- 我们选择缓存热榜数据

- 将数据保存在caffeine中，在获取页面请求时和数据总量时，首先从caffeine中获取。获取不到，再从数据库获取
- 在处理类中执行init方法，初始化caffeine的builder方法。只执行一次即可





对比：未加入

![image-20220329160436610](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220329160436610.png)

加入后

![image-20220329160728015](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220329160728015.png)



**访问index页面 1500**

![image-20220509160341897](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220509160341897.png)

**访问热帖网站：1700**

![image-20220509160921313](%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B.assets/image-20220509160921313.png)

